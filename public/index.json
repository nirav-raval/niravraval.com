[{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below examples shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"}]