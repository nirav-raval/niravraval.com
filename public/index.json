[{"content":"Back inÂ November 2024, Microsoft introduced newÂ AI-powered agentsÂ in Microsoft 365 Copilot to improve productivity by automating task.Â Declarative agentsÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â Today, we will create a custom declarative agent using an open-source API to demonstrate how agents can interact with external data sources.\nOpen Source API Overview:\nWe\u0026rsquo;ll be using theÂ Breaking Bad API, an open-source API that provides quotes from the popular TV seriesÂ Breaking Bad. The API response will return a quote along with the author\u0026rsquo;s name (character name) from the series.\nLetâ€™s get started!\nStep 1: Creating a Custom Declarative Agent Using Microsoft Toolkit Extension Let\u0026rsquo;s begin by creating a custom declarative agent using the Microsoft Toolkit extension. Follow these step-by-step instructions to set up your agent:Â Launch the Microsoft Toolkit Extension and click on Create a New App under Create a Project or Explore Samples Choose Agent as your app type Select Declarative Agent to build an agent powered by Microsoft 365 Copilot Click Add Plugin to connect external APIs to your agent Choose Start with a New API to set up a fresh connection for your agent Pick None for authentication since the Breaking Bad API doesnâ€™t require it Opt for TypeScript as programming language for a smoother experience Select a folder to store project files (pro tip: avoid saving it in the C drive for better organization) Finally, give your agent a name like BreakingBad Agent and hit the setup button Wohooo!Â ðŸŽ‰Â You\u0026rsquo;ve Successfully Created Your Declarative Agent with an API Plugin! After completing the setup, a new window will pop up inÂ VS CodeÂ with your project structure ready. But waitâ€”there\u0026rsquo;s more!Â By default, the project folder includes a demo API plugin. However, this plugin uses a local json file as its data source. Since we want to fetch real-time data from an actual API, we will need to remove the existing demo setup.\nClean Up the Default Files\nNow that your declarative agent is set up, it\u0026rsquo;s time to remove the default files that use local data. Since we will be working with a live API instead, delete the following files from your project directory:Â appPackage \u0026gt; apiSpecificationfile \u0026gt; repair.ymlÂ appPackage \u0026gt; repairDeclarativeAgent.jsonÂ src \u0026gt; RepairsData.jsonÂ src \u0026gt; functions \u0026gt; repairs.ts\nDonâ€™t worry about the files we just deleted. Weâ€™re going to create the essential files needed for ourÂ Breaking Bad AgentÂ from scratch. Up next, weâ€™ll fetch real-time data directly from the API and configure the agent to use it.\nStep 2: Create a New Function File for the Breaking Bad API Integration Next, we need to create a new file where our agent will interact with theÂ Breaking Bad API.Â Navigate to:Â src \u0026gt; functions Create a New File:Â Name itÂ quotes.ts Now, copy and paste the following code intoÂ quotes.ts. This function will act as anÂ Azure FunctionÂ responsible for sending requests and receiving quotes from the live Breaking Bad API.\nimportÂ {Â app,Â HttpResponseInitÂ }Â fromÂ \u0026#34;@azure/functions\u0026#34;;Â exportÂ asyncÂ functionÂ quotes():Â Promise\u0026lt;HttpResponseInit\u0026gt; {Â constÂ breakingbadResponseÂ =Â awaitÂ fetch(\u0026#39;https://api.breakingbadquotes.xyz/v1/quotes\u0026#39;);Â constÂ breakingbadDataÂ =Â awaitÂ breakingbadResponse.json();Â returnÂ {Â status:Â 200,Â jsonBody:Â {Â quotes:Â breakingbadData,Â },Â };Â }Â app.http(\u0026#34;quotes\u0026#34;, {Â methods:Â [\u0026#34;GET\u0026#34;],Â authLevel:Â \u0026#34;anonymous\u0026#34;,Â handler:Â quotes,Â }); If you encounter the error Cannot find module '@azure/functions' or its corresponding type, donâ€™t worry! This is a common issue, and the required modules will be automatically installed when you run the agent for the first time.\nStep 3: Create the API Specification File Now, let\u0026rsquo;s create the API specification file that will define how the declarative agent interacts with theÂ Breaking Bad API.\nNavigate to:Â appPackage \u0026gt; apiSpecificationfile Create a New File:Â Name itÂ quotes.yml openapi:Â 3.0.0Â info:Â title:Â Breaking bad Quote APIÂ description:Â Random Quote api from the Breaking Bad TV series with authorÂ version:Â 1.0.0Â servers:Â -Â url:Â ${{OPENAPI_SERVER_URL}}/apiÂ description:Â The quotes api serverÂ paths:Â /quotes:Â get:Â operationId:Â getQuotesÂ summary:Â get all breaking bad quotes with authorÂ description:Â Returns a single random quote from the Breaking Bad TV series with authorÂ responses:Â \u0026#39;200\u0026#39;:Â description:Â A random quote from the Breaking Bad TV series with authorÂ content:Â application/json:Â schema:Â type:Â objectÂ properties:Â results:Â type:Â arrayÂ items:Â type:Â objectÂ properties:Â quote:Â type:Â stringÂ description:Â Breaking bad quote with authorÂ author:Â type:Â stringÂ description:Â The author name of the quote Step 4: Update theÂ ai-plugin.jsonÂ File Now, let\u0026rsquo;s update the ai-plugin.json file so that the declarative agent is properly linked with the Breaking Bad API and the Azure Function.Â Navigate to:Â appPackage.Â Open the File: OpenÂ ai-plugin.json Remove:Â The \u0026quot;Static_template\u0026quot; entry Update:Â The runtimes URL and the function name as shown below: {Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json)\u0026#34;,Â \u0026#34;schema_version\u0026#34;:Â \u0026#34;v2.2\u0026#34;,Â \u0026#34;namespace\u0026#34;:Â \u0026#34;Breakingbadquotes\u0026#34;,Â \u0026#34;name_for_human\u0026#34;:Â \u0026#34;Breakingbadquotes Plugin\u0026#34;,Â \u0026#34;description_for_human\u0026#34;:Â \u0026#34;Generate random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;description_for_model\u0026#34;:Â \u0026#34;Plugin for generating random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;functions\u0026#34;: [Â {Â \u0026#34;name\u0026#34;:Â \u0026#34;getQuotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;Returns a random quote with author from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;response_semantics\u0026#34;: {Â \u0026#34;data_path\u0026#34;:Â \u0026#34;$.quotes\u0026#34;,Â \u0026#34;properties\u0026#34;: {Â \u0026#34;title\u0026#34;:Â \u0026#34;$.quote\u0026#34;,Â \u0026#34;subtitle\u0026#34;:Â \u0026#34;$.author\u0026#34;Â }Â }Â }Â } ],Â \u0026#34;runtimes\u0026#34;: [Â {Â \u0026#34;type\u0026#34;:Â \u0026#34;OpenApi\u0026#34;,Â \u0026#34;auth\u0026#34;: {Â \u0026#34;type\u0026#34;:Â \u0026#34;None\u0026#34;Â },Â \u0026#34;spec\u0026#34;: {Â \u0026#34;url\u0026#34;:Â \u0026#34;apiSpecificationFile/quotes.yml\u0026#34;,Â \u0026#34;progress_style\u0026#34;:Â \u0026#34;ShowUsageWithInputAndOutput\u0026#34;Â },Â \u0026#34;run_for_functions\u0026#34;: [\u0026#34;getQuotes\u0026#34;]Â }Â ],Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;conversation_starters\u0026#34;: []Â }Â } Step 5: Update the manifest.json File The manifest.json file serves as the app manifest for your declarative agent. It is specifying the agentâ€™s identity and the declarative agent configuration files. We\u0026rsquo;ll update it to reflect the Breaking Bad agent setup.\nNavigate to:Â appPackage Open the File:Â openÂ manifest.json Update:Â The \u0026quot;copilotAgents\u0026quot; section as shown below: You can also update the icon of your application in the same file. First, download any image and make sure it\u0026rsquo;s 192x192 pixels. Replace the existing icon with your new image by saving it as color.png in your project folder. If you choose to change the name of the image, make sure to update it in the application manifest.json file.\n{Â \u0026#34;copilotAgents\u0026#34;: {Â \u0026#34;declarativeAgents\u0026#34;: [Â {Â \u0026#34;id\u0026#34;: \u0026#34;breakingBadDeclarativeAgent\u0026#34;,Â \u0026#34;file\u0026#34;: \u0026#34;breakingBadDeclarativeAgent.json\u0026#34;Â }Â ]Â }Â } Step 6: Create the quotesDeclarativeAgent.json File We need to create theÂ agent manifest fileÂ which defines how the declarative agent behaves and interacts with the Breaking Bad API.\nNavigate to:Â appPackage Create a New File:Â Name itÂ quotesDeclarativeAgent.json Add the Following Content:\n{Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json)\u0026#34;,Â \u0026#34;version\u0026#34;:Â \u0026#34;v1.2\u0026#34;,Â \u0026#34;name\u0026#34;:Â \u0026#34;Breaking badquotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;This declarative agent helps you get a random quote from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;instructions\u0026#34;:Â \u0026#34;$[file(\u0026#39;instruction.txt\u0026#39;)]\u0026#34;,Â \u0026#34;conversation_starters\u0026#34;: [Â {Â \u0026#34;text\u0026#34;:Â \u0026#34;Give me a random quote from Breaking Bad with author name?\u0026#34;Â } ],Â \u0026#34;actions\u0026#34;: [Â {Â \u0026#34;id\u0026#34;:Â \u0026#34;quoteplugin\u0026#34;,Â \u0026#34;file\u0026#34;:Â \u0026#34;ai-plugin.json\u0026#34;Â }Â ]Â } Step 7: Update the instructions.txt File The instructions.txt file plays a crucial role in declarative agent setup. It defines how the agent should behave, respond to user queries, and interact with the Breaking Bad API. This make sures that the agent stays focused on its purpose and maintains a consistent user experience.\nUpdate it with the Following Content:\nYou are an assistant specialized in retrieving quotes from the provided API, ensuring a smooth and delightful user experience. Your responses should include the quote and its author.Â Guidelines:Â - Exclusive API Use: Do not perform web searches; rely solely on the provided API for data retrieval. Do not proceess any other request. This is solely for breaking bad quotes nothing else, keep in mind!Â - Response Format: Present the quote followed by the author\u0026#39;s name.Â - Error Handling: If the API does not return a quote, respond with: \u0026#34;I\u0026#39;m sorry, I couldn\u0026#39;t retrieve a quote at this moment.\u0026#34;Â - User Interaction: Maintain a friendly and engaging tone to ensure a delightful user experience. Showcase: The Final Outcome of All Efforts To run and debug your declarative agent, click on theÂ Run and DebugÂ icon inÂ VS Code, which can be found on the left sidebar. The process will take approximatelyÂ ~10-15 minutesÂ to initialize. During this time, a sign-in prompt will appear where youâ€™ll need to log in with yourÂ Microsoft 365 accountÂ credentials.\nOnce signed in, if you are not automatically redirected, you can manually visitÂ office.com/chat?auth=2Â to access the Copilot interface.\nSelect the prompt we defined earlier, and it will prompt you to process the query. Click on Always Allow to proceed.\nView the results\nHow to Verify if It\u0026rsquo;s Working and Fetching Data from the API\nVerify via Localhost: Open the terminal in VS Code and click on Start Backend. Once it\u0026rsquo;s running, you\u0026rsquo;ll see the local host URL, which should begin with localhost:7071/api/quotes. Open this URL in your browser, and it will return a JSON response with the quote data. Verify via Agent Request: Another way to check is by sending a request from the agent. This will invoke the getQuote function, which generates a unique ID each time. The response will include text indicating that the function was programmatically called. Bonus: How does the breaking bad quotes agent work? When a user requests a Breaking Bad quote in Microsoft 365 Copilot, the agent works in a few simple steps:Â Manifest Check:Â The agent starts by checking its task list in theÂ manifest file API Connection:Â It then refers to theÂ API specificationÂ to understand how to connect to the Breaking Bad API Data Fetch:Â The agent sends a request to anÂ Azure Function, which fetches a random quote and the authorâ€™s name from the API Data Return:Â The quote and author are returned in a structured JSON format User Display:Â Finally, the agent displays the quote clearly in the Copilot interface Conclusion Itâ€™s been a bit of a ride, hasnâ€™t it? But hey, weâ€™ve finally done it! We have successfully created a declarative agent using the Breaking Bad API, but the process can be applied to any API, including those requiring authentication with API key or OAuth.\nif you hit any bumps along the way, donâ€™t hesitate to drop a comment below. Iâ€™m here to help, like your personal Jesse Pinkman for coding! Good Luck!\nAppendix:\nThis post is inspired by the following resources:\nIntroducing New Agents in Microsoft 365 Extending Copilot for Microsoft 365 Workshop on Building Declarative Agents for Microsoft 365 Copilot Breaking Bad Quotes API [Breaking Bad Icon by Icons8](Breaking Bad icon by Icons8) ","permalink":"http://localhost:1313/blog/2025/january/create-a-custom-declarative-agent-with-breaking-bad-api/","summary":"\u003cp\u003eBack inÂ November 2024, Microsoft introduced newÂ \u003ca href=\"https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918?utm_source=chatgpt.com\"\u003eAI-powered agents\u003c/a\u003eÂ in Microsoft 365 Copilot to improve productivity by automating task.Â Â \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/overview-declarative-agent\"\u003eDeclarative agents\u003c/a\u003eÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â \u003c/p\u003e","title":"Create a Custom Declarative Agent with Breaking Bad API"},{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below example shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"},{"content":"Back inÂ November 2024, Microsoft introduced newÂ AI-powered agentsÂ in Microsoft 365 Copilot.Â Declarative agentsÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â Today, we will create a custom declarative agent using an open-source API to demonstrate how agents can interact with external data sources.\nOpen Source API Overview:\nWe\u0026rsquo;ll be using theÂ Breaking Bad API, an open-source API that provides quotes from the popular TV seriesÂ Breaking Bad. The API response will return a quote along with the author\u0026rsquo;s name (character name) from the series.\nLetâ€™s get started!\nStep 1: Creating a Custom Declarative Agent Using Microsoft Toolkit Extension Let\u0026rsquo;s begin by creating a custom declarative agent using the Microsoft Toolkit extension. Follow these step-by-step instructions to set up your agent:Â Launch the Microsoft Toolkit Extension and click on Create a New App under Create a Project or Explore Samples Choose Agent as your app type Select Declarative Agent to build an agent powered by Microsoft 365 Copilot Click Add Plugin to connect external APIs to your agent Choose Start with a New API to set up a fresh connection for your agent Pick None for authentication since the Breaking Bad API doesnâ€™t require it Opt for TypeScript as programming language for a smoother experience Select a folder to store project files (pro tip: avoid saving it in the C drive for better organization) Finally, give your agent a name like BreakingBad Agent and hit the setup button Wohooo!Â ðŸŽ‰Â You\u0026rsquo;ve Successfully Created Your Declarative Agent with an API Plugin! After completing the setup, a new window will pop up inÂ VS CodeÂ with your project structure ready. But waitâ€”there\u0026rsquo;s more!Â By default, the project folder includes a demo API plugin. However, this plugin uses a local json file as its data source. Since we want to fetch real-time data from an actual API, we will need to remove the existing demo setup.\nClean Up the Default Files\nNow that your declarative agent is set up, it\u0026rsquo;s time to remove the default files that use local data. Since we will be working with a live API instead, delete the following files from your project directory:Â appPackage \u0026gt; apiSpecificationfile \u0026gt; repair.ymlÂ appPackage \u0026gt; repairDeclarativeAgent.jsonÂ src \u0026gt; RepairsData.jsonÂ src \u0026gt; functions \u0026gt; repairs.ts\nDonâ€™t worry about the files we just deleted. Weâ€™re going to create the essential files needed for ourÂ Breaking Bad AgentÂ from scratch. Up next, weâ€™ll fetch real-time data directly from the API and configure the agent to use it.\nStep 2: Create a New Function File for the Breaking Bad API Integration Next, we need to create a new file where our agent will interact with theÂ Breaking Bad API.Â Navigate to:Â src \u0026gt; functions Create a New File:Â Name itÂ quotes.ts Now, copy and paste the following code intoÂ quotes.ts. This function will act as anÂ Azure FunctionÂ responsible for sending requests and receiving quotes from the live Breaking Bad API.\nimportÂ {Â app,Â HttpResponseInitÂ }Â fromÂ \u0026#34;@azure/functions\u0026#34;;Â exportÂ asyncÂ functionÂ quotes():Â Promise\u0026lt;HttpResponseInit\u0026gt; {Â constÂ breakingbadResponseÂ =Â awaitÂ fetch(\u0026#39;https://api.breakingbadquotes.xyz/v1/quotes\u0026#39;);Â constÂ breakingbadDataÂ =Â awaitÂ breakingbadResponse.json();Â returnÂ {Â status:Â 200,Â jsonBody:Â {Â quotes:Â breakingbadData,Â },Â };Â }Â app.http(\u0026#34;quotes\u0026#34;, {Â methods:Â [\u0026#34;GET\u0026#34;],Â authLevel:Â \u0026#34;anonymous\u0026#34;,Â handler:Â quotes,Â }); If you encounter the error Cannot find module '@azure/functions' or its corresponding type, donâ€™t worry! This is a common issue, and the required modules will be automatically installed when you run the agent for the first time.\nStep 3: Create the API Specification File Now, let\u0026rsquo;s create the API specification file that will define how the declarative agent interacts with theÂ Breaking Bad API.\nNavigate to:Â appPackage \u0026gt; apiSpecificationfile Create a New File:Â Name itÂ quotes.yml openapi:Â 3.0.0Â info:Â title:Â Breaking bad Quote APIÂ description:Â Random Quote api from the Breaking Bad TV series with authorÂ version:Â 1.0.0Â servers:Â -Â url:Â ${{OPENAPI_SERVER_URL}}/apiÂ description:Â The quotes api serverÂ paths:Â /quotes:Â get:Â operationId:Â getQuotesÂ summary:Â get all breaking bad quotes with authorÂ description:Â Returns a single random quote from the Breaking Bad TV series with authorÂ responses:Â \u0026#39;200\u0026#39;:Â description:Â A random quote from the Breaking Bad TV series with authorÂ content:Â application/json:Â schema:Â type:Â objectÂ properties:Â results:Â type:Â arrayÂ items:Â type:Â objectÂ properties:Â quote:Â type:Â stringÂ description:Â Breaking bad quote with authorÂ author:Â type:Â stringÂ description:Â The author name of the quote Step 4: Update theÂ ai-plugin.jsonÂ File Now, let\u0026rsquo;s update the ai-plugin.json file so that the declarative agent is properly linked with the Breaking Bad API and the Azure Function.Â Navigate to:Â appPackage.Â Open the File: OpenÂ ai-plugin.json Remove:Â The \u0026quot;Static_template\u0026quot; entry Update:Â The runtimes URL and the function name as shown below: {Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json)\u0026#34;,Â \u0026#34;schema_version\u0026#34;:Â \u0026#34;v2.2\u0026#34;,Â \u0026#34;namespace\u0026#34;:Â \u0026#34;Breakingbadquotes\u0026#34;,Â \u0026#34;name_for_human\u0026#34;:Â \u0026#34;Breakingbadquotes Plugin\u0026#34;,Â \u0026#34;description_for_human\u0026#34;:Â \u0026#34;Generate random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;description_for_model\u0026#34;:Â \u0026#34;Plugin for generating random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;functions\u0026#34;: [Â {Â \u0026#34;name\u0026#34;:Â \u0026#34;getQuotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;Returns a random quote with author from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;response_semantics\u0026#34;: {Â \u0026#34;data_path\u0026#34;:Â \u0026#34;$.quotes\u0026#34;,Â \u0026#34;properties\u0026#34;: {Â \u0026#34;title\u0026#34;:Â \u0026#34;$.quote\u0026#34;,Â \u0026#34;subtitle\u0026#34;:Â \u0026#34;$.author\u0026#34;Â }Â }Â }Â } ],Â \u0026#34;runtimes\u0026#34;: [Â {Â \u0026#34;type\u0026#34;:Â \u0026#34;OpenApi\u0026#34;,Â \u0026#34;auth\u0026#34;: {Â \u0026#34;type\u0026#34;:Â \u0026#34;None\u0026#34;Â },Â \u0026#34;spec\u0026#34;: {Â \u0026#34;url\u0026#34;:Â \u0026#34;apiSpecificationFile/quotes.yml\u0026#34;,Â \u0026#34;progress_style\u0026#34;:Â \u0026#34;ShowUsageWithInputAndOutput\u0026#34;Â },Â \u0026#34;run_for_functions\u0026#34;: [\u0026#34;getQuotes\u0026#34;]Â }Â ],Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;conversation_starters\u0026#34;: []Â }Â } Step 5: Update the manifest.json File The manifest.json file serves as the app manifest for your declarative agent. It is specifying the agentâ€™s identity and the declarative agent configuration files. We\u0026rsquo;ll update it to reflect the Breaking Bad agent setup.\nNavigate to:Â appPackage Open the File:Â openÂ manifest.json Update:Â The \u0026quot;copilotAgents\u0026quot; section as shown below: You can also update the icon of your application in the same file. First, download any image and make sure it\u0026rsquo;s 192x192 pixels. Replace the existing icon with your new image by saving it as color.png in your project folder. If you choose to change the name of the image, make sure to update it in the application manifest.json file.\n{Â \u0026#34;copilotAgents\u0026#34;: {Â \u0026#34;declarativeAgents\u0026#34;: [Â {Â \u0026#34;id\u0026#34;: \u0026#34;breakingBadDeclarativeAgent\u0026#34;,Â \u0026#34;file\u0026#34;: \u0026#34;breakingBadDeclarativeAgent.json\u0026#34;Â }Â ]Â }Â } Step 6: Create the quotesDeclarativeAgent.json File We need to create theÂ agent manifest fileÂ which defines how the declarative agent behaves and interacts with the Breaking Bad API.\nNavigate to:Â appPackage Create a New File:Â Name itÂ quotesDeclarativeAgent.json Add the Following Content:\n{Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json)\u0026#34;,Â \u0026#34;version\u0026#34;:Â \u0026#34;v1.2\u0026#34;,Â \u0026#34;name\u0026#34;:Â \u0026#34;Breaking badquotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;This declarative agent helps you get a random quote from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;instructions\u0026#34;:Â \u0026#34;$[file(\u0026#39;instruction.txt\u0026#39;)]\u0026#34;,Â \u0026#34;conversation_starters\u0026#34;: [Â {Â \u0026#34;text\u0026#34;:Â \u0026#34;Give me a random quote from Breaking Bad with author name?\u0026#34;Â } ],Â \u0026#34;actions\u0026#34;: [Â {Â \u0026#34;id\u0026#34;:Â \u0026#34;quoteplugin\u0026#34;,Â \u0026#34;file\u0026#34;:Â \u0026#34;ai-plugin.json\u0026#34;Â }Â ]Â } Step 7: Update the instructions.txt File The instructions.txt file plays a crucial role in declarative agent setup. It defines how the agent should behave, respond to user queries, and interact with the Breaking Bad API. This make sures that the agent stays focused on its purpose and maintains a consistent user experience.\nUpdate it with the Following Content:\nYou are an assistant specialized in retrieving quotes from the provided API, ensuring a smooth and delightful user experience. Your responses should include the quote and its author.Â Guidelines:Â - Exclusive API Use: Do not perform web searches; rely solely on the provided API for data retrieval. Do not proceess any other request. This is solely for breaking bad quotes nothing else, keep in mind!Â - Response Format: Present the quote followed by the author\u0026#39;s name.Â - Error Handling: If the API does not return a quote, respond with: \u0026#34;I\u0026#39;m sorry, I couldn\u0026#39;t retrieve a quote at this moment.\u0026#34;Â - User Interaction: Maintain a friendly and engaging tone to ensure a delightful user experience. Showcase: The Final Outcome of All Efforts To run and debug your declarative agent, click on theÂ Run and DebugÂ icon inÂ VS Code, which can be found on the left sidebar. The process will take approximatelyÂ ~10-15 minutesÂ to initialize. During this time, a sign-in prompt will appear where youâ€™ll need to log in with yourÂ Microsoft 365 accountÂ credentials.\nOnce signed in, if you are not automatically redirected, you can manually visitÂ office.com/chat?auth=2Â to access the Copilot interface.\nSelect the prompt we defined earlier, and it will prompt you to process the query. Click on Always Allow to proceed.\nFinal Output:\nHow to Verify if It\u0026rsquo;s Working and Fetching Data from the API\nVerify via Localhost: Open the terminal in VS Code and click on Start Backend. Once it\u0026rsquo;s running, you\u0026rsquo;ll see the local host URL, which should begin with localhost:7071/api/quotes. Open this URL in your browser, and it will return a JSON response with the quote data. Verify via Agent Request: Another way to check is by sending a request from the agent. This will invoke the getQuote function, which generates a unique ID each time. The response will include text indicating that the function was programmatically called. Bonus: How does the breaking bad quotes agent work? When a user requests a Breaking Bad quote in Microsoft 365 Copilot, the agent works in a few simple steps:Â Manifest Check:Â The agent starts by checking its task list in theÂ manifest file API Connection:Â It then refers to theÂ API specificationÂ to understand how to connect to the Breaking Bad API Data Fetch:Â The agent sends a request to anÂ Azure Function, which fetches a random quote and the authorâ€™s name from the API Data Return:Â The quote and author are returned in a structured JSON format User Display:Â Finally, the agent displays the quote clearly in the Copilot interface Conclusion Itâ€™s been a bit of a ride, hasnâ€™t it? But hey, weâ€™ve finally done it! We have successfully created a declarative agent using the Breaking Bad API, but the process can be applied to any API, including those requiring authentication with API key or OAuth.\nif you hit any bumps along the way, donâ€™t hesitate to drop a comment below. If you found this helpful, give it a thumbs up or click on your favorite emoji button below. Good luck, and happy coding!\nAppendix\nThis post is inspired by the following resources:\nIntroducing New Agents in Microsoft 365 Extending Copilot for Microsoft 365 Workshop on Building Declarative Agents for Microsoft 365 Copilot Breaking Bad Quotes API [Breaking Bad Icon by Icons8](Breaking Bad icon by Icons8) ","permalink":"http://localhost:1313/blog/2025/january/create-a-custom-declarative-agent-with-breaking-bad-api/","summary":"\u003cp\u003eBack inÂ November 2024, Microsoft introduced newÂ \u003ca href=\"https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918?utm_source=chatgpt.com\"\u003eAI-powered agents\u003c/a\u003eÂ in Microsoft 365 Copilot.Â Â \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/overview-declarative-agent\"\u003eDeclarative agents\u003c/a\u003eÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â \u003c/p\u003e","title":"Create a Custom Declarative Agent with Breaking Bad API"},{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below example shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"},{"content":"Back inÂ November 2024, Microsoft introduced newÂ AI-powered agentsÂ in Microsoft 365 Copilot.Â Declarative agentsÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â Today, we will create a custom declarative agent using an open-source API to demonstrate how agents can interact with external data sources.\nOpen Source API Overview:\nWe\u0026rsquo;ll be using theÂ Breaking Bad API, an open-source API that provides quotes from the popular TV seriesÂ Breaking Bad. The API response will return a quote along with the author\u0026rsquo;s name (character name) from the series.\nLetâ€™s get started!\nStep 1: Creating a Custom Declarative Agent Using Microsoft Toolkit Extension Let\u0026rsquo;s begin by creating a custom declarative agent using the Microsoft Toolkit extension. Follow these step-by-step instructions to set up your agent:Â Launch the Microsoft Toolkit Extension and click on Create a New App under Create a Project or Explore Samples Choose Agent as your app type Select Declarative Agent to build an agent powered by Microsoft 365 Copilot Click Add Plugin to connect external APIs to your agent Choose Start with a New API to set up a fresh connection for your agent Pick None for authentication since the Breaking Bad API doesnâ€™t require it Opt for TypeScript as programming language for a smoother experience Select a folder to store project files (pro tip: avoid saving it in the C drive for better organization) Finally, give your agent a name like BreakingBad Agent and hit the setup button Wohooo!Â ðŸŽ‰Â You\u0026rsquo;ve Successfully Created Your Declarative Agent with an API Plugin! After completing the setup, a new window will pop up inÂ VS CodeÂ with your project structure ready. But waitâ€”there\u0026rsquo;s more!Â By default, the project folder includes a demo API plugin. However, this plugin uses a local json file as its data source. Since we want to fetch real-time data from an actual API, we will need to remove the existing demo setup.\nClean Up the Default Files\nNow that your declarative agent is set up, it\u0026rsquo;s time to remove the default files that use local data. Since we will be working with a live API instead, delete the following files from your project directory:Â appPackage \u0026gt; apiSpecificationfile \u0026gt; repair.ymlÂ appPackage \u0026gt; repairDeclarativeAgent.jsonÂ src \u0026gt; RepairsData.jsonÂ src \u0026gt; functions \u0026gt; repairs.ts\nDonâ€™t worry about the files we just deleted. Weâ€™re going to create the essential files needed for ourÂ Breaking Bad AgentÂ from scratch. Up next, weâ€™ll fetch real-time data directly from the API and configure the agent to use it.\nStep 2: Create a New Function File for the Breaking Bad API Integration Next, we need to create a new file where our agent will interact with theÂ Breaking Bad API.Â Navigate to:Â src \u0026gt; functions Create a New File:Â Name itÂ quotes.ts Now, copy and paste the following code intoÂ quotes.ts. This function will act as anÂ Azure FunctionÂ responsible for sending requests and receiving quotes from the live Breaking Bad API.\nimportÂ {Â app,Â HttpResponseInitÂ }Â fromÂ \u0026#34;@azure/functions\u0026#34;;Â exportÂ asyncÂ functionÂ quotes():Â Promise\u0026lt;HttpResponseInit\u0026gt; {Â constÂ breakingbadResponseÂ =Â awaitÂ fetch(\u0026#39;https://api.breakingbadquotes.xyz/v1/quotes\u0026#39;);Â constÂ breakingbadDataÂ =Â awaitÂ breakingbadResponse.json();Â returnÂ {Â status:Â 200,Â jsonBody:Â {Â quotes:Â breakingbadData,Â },Â };Â }Â app.http(\u0026#34;quotes\u0026#34;, {Â methods:Â [\u0026#34;GET\u0026#34;],Â authLevel:Â \u0026#34;anonymous\u0026#34;,Â handler:Â quotes,Â }); If you encounter the error Cannot find module '@azure/functions' or its corresponding type, donâ€™t worry! This is a common issue, and the required modules will be automatically installed when you run the agent for the first time.\nStep 3: Create the API Specification File Now, let\u0026rsquo;s create the API specification file that will define how the declarative agent interacts with theÂ Breaking Bad API.\nNavigate to:Â appPackage \u0026gt; apiSpecificationfile Create a New File:Â Name itÂ quotes.yml openapi:Â 3.0.0Â info:Â title:Â Breaking bad Quote APIÂ description:Â Random Quote api from the Breaking Bad TV series with authorÂ version:Â 1.0.0Â servers:Â -Â url:Â ${{OPENAPI_SERVER_URL}}/apiÂ description:Â The quotes api serverÂ paths:Â /quotes:Â get:Â operationId:Â getQuotesÂ summary:Â get all breaking bad quotes with authorÂ description:Â Returns a single random quote from the Breaking Bad TV series with authorÂ responses:Â \u0026#39;200\u0026#39;:Â description:Â A random quote from the Breaking Bad TV series with authorÂ content:Â application/json:Â schema:Â type:Â objectÂ properties:Â results:Â type:Â arrayÂ items:Â type:Â objectÂ properties:Â quote:Â type:Â stringÂ description:Â Breaking bad quote with authorÂ author:Â type:Â stringÂ description:Â The author name of the quote Step 4: Update theÂ ai-plugin.jsonÂ File Now, let\u0026rsquo;s update the ai-plugin.json file so that the declarative agent is properly linked with the Breaking Bad API and the Azure Function.Â Navigate to:Â appPackage.Â Open the File: OpenÂ ai-plugin.json Remove:Â The \u0026quot;Static_template\u0026quot; entry Update:Â The runtimes URL and the function name as shown below: {Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json)\u0026#34;,Â \u0026#34;schema_version\u0026#34;:Â \u0026#34;v2.2\u0026#34;,Â \u0026#34;namespace\u0026#34;:Â \u0026#34;Breakingbadquotes\u0026#34;,Â \u0026#34;name_for_human\u0026#34;:Â \u0026#34;Breakingbadquotes Plugin\u0026#34;,Â \u0026#34;description_for_human\u0026#34;:Â \u0026#34;Generate random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;description_for_model\u0026#34;:Â \u0026#34;Plugin for generating random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;functions\u0026#34;: [Â {Â \u0026#34;name\u0026#34;:Â \u0026#34;getQuotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;Returns a random quote with author from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;response_semantics\u0026#34;: {Â \u0026#34;data_path\u0026#34;:Â \u0026#34;$.quotes\u0026#34;,Â \u0026#34;properties\u0026#34;: {Â \u0026#34;title\u0026#34;:Â \u0026#34;$.quote\u0026#34;,Â \u0026#34;subtitle\u0026#34;:Â \u0026#34;$.author\u0026#34;Â }Â }Â }Â } ],Â \u0026#34;runtimes\u0026#34;: [Â {Â \u0026#34;type\u0026#34;:Â \u0026#34;OpenApi\u0026#34;,Â \u0026#34;auth\u0026#34;: {Â \u0026#34;type\u0026#34;:Â \u0026#34;None\u0026#34;Â },Â \u0026#34;spec\u0026#34;: {Â \u0026#34;url\u0026#34;:Â \u0026#34;apiSpecificationFile/quotes.yml\u0026#34;,Â \u0026#34;progress_style\u0026#34;:Â \u0026#34;ShowUsageWithInputAndOutput\u0026#34;Â },Â \u0026#34;run_for_functions\u0026#34;: [\u0026#34;getQuotes\u0026#34;]Â }Â ],Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;conversation_starters\u0026#34;: []Â }Â } Step 5: Update the manifest.json File The manifest.json file serves as the app manifest for your declarative agent. It is specifying the agentâ€™s identity and the declarative agent configuration files. We\u0026rsquo;ll update it to reflect the Breaking Bad agent setup.\nNavigate to:Â appPackage Open the File:Â openÂ manifest.json Update:Â The \u0026quot;copilotAgents\u0026quot; section as shown below: You can also update the icon of your application in the same file. First, download any image and make sure it\u0026rsquo;s 192x192 pixels. Replace the existing icon with your new image by saving it as color.png in your project folder. If you choose to change the name of the image, make sure to update it in the application manifest.json file.\n{Â \u0026#34;copilotAgents\u0026#34;: {Â \u0026#34;declarativeAgents\u0026#34;: [Â {Â \u0026#34;id\u0026#34;: \u0026#34;breakingBadDeclarativeAgent\u0026#34;,Â \u0026#34;file\u0026#34;: \u0026#34;breakingBadDeclarativeAgent.json\u0026#34;Â }Â ]Â }Â } Step 6: Create the quotesDeclarativeAgent.json File We need to create theÂ agent manifest fileÂ which defines how the declarative agent behaves and interacts with the Breaking Bad API.\nNavigate to:Â appPackage Create a New File:Â Name itÂ quotesDeclarativeAgent.json Add the Following Content:\n{Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json)\u0026#34;,Â \u0026#34;version\u0026#34;:Â \u0026#34;v1.2\u0026#34;,Â \u0026#34;name\u0026#34;:Â \u0026#34;Breaking badquotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;This declarative agent helps you get a random quote from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;instructions\u0026#34;:Â \u0026#34;$[file(\u0026#39;instruction.txt\u0026#39;)]\u0026#34;,Â \u0026#34;conversation_starters\u0026#34;: [Â {Â \u0026#34;text\u0026#34;:Â \u0026#34;Give me a random quote from Breaking Bad with author name?\u0026#34;Â } ],Â \u0026#34;actions\u0026#34;: [Â {Â \u0026#34;id\u0026#34;:Â \u0026#34;quoteplugin\u0026#34;,Â \u0026#34;file\u0026#34;:Â \u0026#34;ai-plugin.json\u0026#34;Â }Â ]Â } Step 7: Update the instructions.txt File The instructions.txt file plays a crucial role in declarative agent setup. It defines how the agent should behave, respond to user queries, and interact with the Breaking Bad API. This make sures that the agent stays focused on its purpose and maintains a consistent user experience.\nUpdate it with the Following Content:\nYou are an assistant specialized in retrieving quotes from the provided API, ensuring a smooth and delightful user experience. Your responses should include the quote and its author.Â Guidelines:Â - Exclusive API Use: Do not perform web searches; rely solely on the provided API for data retrieval. Do not proceess any other request. This is solely for breaking bad quotes nothing else, keep in mind!Â - Response Format: Present the quote followed by the author\u0026#39;s name.Â - Error Handling: If the API does not return a quote, respond with: \u0026#34;I\u0026#39;m sorry, I couldn\u0026#39;t retrieve a quote at this moment.\u0026#34;Â - User Interaction: Maintain a friendly and engaging tone to ensure a delightful user experience. Showcase: The Final Outcome of All Efforts To run and debug your declarative agent, click on theÂ Run and DebugÂ icon inÂ VS Code, which can be found on the left sidebar. The process will take approximatelyÂ ~10-15 minutesÂ to initialize. During this time, a sign-in prompt will appear where youâ€™ll need to log in with yourÂ Microsoft 365 accountÂ credentials.\nOnce signed in, if you are not automatically redirected, you can manually visitÂ office.com/chat?auth=2Â to access the Copilot interface.\nSelect the prompt we defined earlier, and it will prompt you to process the query. Click on Always Allow to proceed.\nFinal Output:\nHow to Verify if It\u0026rsquo;s Working and Fetching Data from the API\nVerify via Localhost: Open the terminal in VS Code and click on Start Backend. Once it\u0026rsquo;s running, you\u0026rsquo;ll see the local host URL, which should begin with localhost:7071/api/quotes. Open this URL in your browser, and it will return a JSON response with the quote data. Verify via Agent Request: Another way to check is by sending a request from the agent. This will invoke the getQuote function, which generates a unique ID each time. The response will include text indicating that the function was programmatically called. Bonus: How does the breaking bad quotes agent work? When a user requests a Breaking Bad quote in Microsoft 365 Copilot, the agent works in a few simple steps:Â Manifest Check:Â The agent starts by checking its task list in theÂ manifest file API Connection:Â It then refers to theÂ API specificationÂ to understand how to connect to the Breaking Bad API Data Fetch:Â The agent sends a request to anÂ Azure Function, which fetches a random quote and the authorâ€™s name from the API Data Return:Â The quote and author are returned in a structured JSON format User Display:Â Finally, the agent displays the quote clearly in the Copilot interface Conclusion Itâ€™s been a bit of a ride, hasnâ€™t it? But hey, weâ€™ve finally done it! We have successfully created a declarative agent using the Breaking Bad API, but the process can be applied to any API, including those requiring authentication with API key or OAuth.\nif you hit any bumps along the way, donâ€™t hesitate to drop a comment below. If you found this helpful, give it a thumbs up or click on your favorite emoji button below. Good luck, and happy coding!\nAppendix\nThis post is inspired by the following resources:\nIntroducing New Agents in Microsoft 365 Extending Copilot for Microsoft 365 Workshop on Building Declarative Agents for Microsoft 365 Copilot Breaking Bad Quotes API Breaking Bad Icon by Icons8 ","permalink":"http://localhost:1313/blog/2025/january/create-a-custom-declarative-agent-with-breaking-bad-api/","summary":"\u003cp\u003eBack inÂ November 2024, Microsoft introduced newÂ \u003ca href=\"https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918?utm_source=chatgpt.com\"\u003eAI-powered agents\u003c/a\u003eÂ in Microsoft 365 Copilot.Â Â \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/overview-declarative-agent\"\u003eDeclarative agents\u003c/a\u003eÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â \u003c/p\u003e","title":"Create a Custom Declarative Agent with Breaking Bad API"},{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below example shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"},{"content":"Back inÂ November 2024, Microsoft introduced newÂ AI-powered agentsÂ in Microsoft 365 Copilot.Â Declarative agentsÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â Today, we will create a custom declarative agent using an open-source API to demonstrate how agents can interact with external data sources.\nOpen Source API Overview:\nWe\u0026rsquo;ll be using theÂ Breaking Bad API, an open-source API that provides quotes from the popular TV seriesÂ Breaking Bad. The API response will return a quote along with the author\u0026rsquo;s name (character name) from the series.\nH\nLetâ€™s get started!\nStep 1: Creating a Custom Declarative Agent Using Microsoft Toolkit Extension Let\u0026rsquo;s begin by creating a custom declarative agent using the Microsoft Toolkit extension. Follow these step-by-step instructions to set up your agent:Â Launch the Microsoft Toolkit Extension and click on Create a New App under Create a Project or Explore Samples Choose Agent as your app type Select Declarative Agent to build an agent powered by Microsoft 365 Copilot Click Add Plugin to connect external APIs to your agent Choose Start with a New API to set up a fresh connection for your agent Pick None for authentication since the Breaking Bad API doesnâ€™t require it Opt for TypeScript as programming language for a smoother experience Select a folder to store project files (pro tip: avoid saving it in the C drive for better organization) Finally, give your agent a name like BreakingBad Agent and hit the setup button Wohooo!Â ðŸŽ‰Â You\u0026rsquo;ve Successfully Created Your Declarative Agent with an API Plugin! After completing the setup, a new window will pop up inÂ VS CodeÂ with your project structure ready. But waitâ€”there\u0026rsquo;s more!Â By default, the project folder includes a demo API plugin. However, this plugin uses a local json file as its data source. Since we want to fetch real-time data from an actual API, we will need to remove the existing demo setup.\nClean Up the Default Files\nNow that your declarative agent is set up, it\u0026rsquo;s time to remove the default files that use local data. Since we will be working with a live API instead, delete the following files from your project directory:Â appPackage \u0026gt; apiSpecificationfile \u0026gt; repair.ymlÂ appPackage \u0026gt; repairDeclarativeAgent.jsonÂ src \u0026gt; RepairsData.jsonÂ src \u0026gt; functions \u0026gt; repairs.ts\nDonâ€™t worry about the files we just deleted. Weâ€™re going to create the essential files needed for ourÂ Breaking Bad AgentÂ from scratch. Up next, weâ€™ll fetch real-time data directly from the API and configure the agent to use it.\nStep 2: Create a New Function File for the Breaking Bad API Integration Next, we need to create a new file where our agent will interact with theÂ Breaking Bad API.Â Navigate to:Â src \u0026gt; functions Create a New File:Â Name itÂ quotes.ts Now, copy and paste the following code intoÂ quotes.ts. This function will act as anÂ Azure FunctionÂ responsible for sending requests and receiving quotes from the live Breaking Bad API.\nimportÂ {Â app,Â HttpResponseInitÂ }Â fromÂ \u0026#34;@azure/functions\u0026#34;;Â exportÂ asyncÂ functionÂ quotes():Â Promise\u0026lt;HttpResponseInit\u0026gt; {Â constÂ breakingbadResponseÂ =Â awaitÂ fetch(\u0026#39;https://api.breakingbadquotes.xyz/v1/quotes\u0026#39;);Â constÂ breakingbadDataÂ =Â awaitÂ breakingbadResponse.json();Â returnÂ {Â status:Â 200,Â jsonBody:Â {Â quotes:Â breakingbadData,Â },Â };Â }Â app.http(\u0026#34;quotes\u0026#34;, {Â methods:Â [\u0026#34;GET\u0026#34;],Â authLevel:Â \u0026#34;anonymous\u0026#34;,Â handler:Â quotes,Â }); If you encounter the error Cannot find module '@azure/functions' or its corresponding type, donâ€™t worry! This is a common issue, and the required modules will be automatically installed when you run the agent for the first time.\nStep 3: Create the API Specification File Now, let\u0026rsquo;s create the API specification file that will define how the declarative agent interacts with theÂ Breaking Bad API.\nNavigate to:Â appPackage \u0026gt; apiSpecificationfile Create a New File:Â Name itÂ quotes.yml openapi:Â 3.0.0Â info:Â title:Â Breaking bad Quote APIÂ description:Â Random Quote api from the Breaking Bad TV series with authorÂ version:Â 1.0.0Â servers:Â -Â url:Â ${{OPENAPI_SERVER_URL}}/apiÂ description:Â The quotes api serverÂ paths:Â /quotes:Â get:Â operationId:Â getQuotesÂ summary:Â get all breaking bad quotes with authorÂ description:Â Returns a single random quote from the Breaking Bad TV series with authorÂ responses:Â \u0026#39;200\u0026#39;:Â description:Â A random quote from the Breaking Bad TV series with authorÂ content:Â application/json:Â schema:Â type:Â objectÂ properties:Â results:Â type:Â arrayÂ items:Â type:Â objectÂ properties:Â quote:Â type:Â stringÂ description:Â Breaking bad quote with authorÂ author:Â type:Â stringÂ description:Â The author name of the quote Step 4: Update theÂ ai-plugin.jsonÂ File Now, let\u0026rsquo;s update the ai-plugin.json file so that the declarative agent is properly linked with the Breaking Bad API and the Azure Function.Â Navigate to:Â appPackage.Â Open the File: OpenÂ ai-plugin.json Remove:Â The \u0026quot;Static_template\u0026quot; entry Update:Â The runtimes URL and the function name as shown below: {Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json)\u0026#34;,Â \u0026#34;schema_version\u0026#34;:Â \u0026#34;v2.2\u0026#34;,Â \u0026#34;namespace\u0026#34;:Â \u0026#34;Breakingbadquotes\u0026#34;,Â \u0026#34;name_for_human\u0026#34;:Â \u0026#34;Breakingbadquotes Plugin\u0026#34;,Â \u0026#34;description_for_human\u0026#34;:Â \u0026#34;Generate random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;description_for_model\u0026#34;:Â \u0026#34;Plugin for generating random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;functions\u0026#34;: [Â {Â \u0026#34;name\u0026#34;:Â \u0026#34;getQuotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;Returns a random quote with author from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;response_semantics\u0026#34;: {Â \u0026#34;data_path\u0026#34;:Â \u0026#34;$.quotes\u0026#34;,Â \u0026#34;properties\u0026#34;: {Â \u0026#34;title\u0026#34;:Â \u0026#34;$.quote\u0026#34;,Â \u0026#34;subtitle\u0026#34;:Â \u0026#34;$.author\u0026#34;Â }Â }Â }Â } ],Â \u0026#34;runtimes\u0026#34;: [Â {Â \u0026#34;type\u0026#34;:Â \u0026#34;OpenApi\u0026#34;,Â \u0026#34;auth\u0026#34;: {Â \u0026#34;type\u0026#34;:Â \u0026#34;None\u0026#34;Â },Â \u0026#34;spec\u0026#34;: {Â \u0026#34;url\u0026#34;:Â \u0026#34;apiSpecificationFile/quotes.yml\u0026#34;,Â \u0026#34;progress_style\u0026#34;:Â \u0026#34;ShowUsageWithInputAndOutput\u0026#34;Â },Â \u0026#34;run_for_functions\u0026#34;: [\u0026#34;getQuotes\u0026#34;]Â }Â ],Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;conversation_starters\u0026#34;: []Â }Â } Step 5: Update the manifest.json File The manifest.json file serves as the app manifest for your declarative agent. It is specifying the agentâ€™s identity and the declarative agent configuration files. We\u0026rsquo;ll update it to reflect the Breaking Bad agent setup.\nNavigate to:Â appPackage Open the File:Â openÂ manifest.json Update:Â The \u0026quot;copilotAgents\u0026quot; section as shown below: You can also update the icon of your application in the same file. First, download any image and make sure it\u0026rsquo;s 192x192 pixels. Replace the existing icon with your new image by saving it as color.png in your project folder. If you choose to change the name of the image, make sure to update it in the application manifest.json file.\n{Â \u0026#34;copilotAgents\u0026#34;: {Â \u0026#34;declarativeAgents\u0026#34;: [Â {Â \u0026#34;id\u0026#34;: \u0026#34;breakingBadDeclarativeAgent\u0026#34;,Â \u0026#34;file\u0026#34;: \u0026#34;breakingBadDeclarativeAgent.json\u0026#34;Â }Â ]Â }Â } Step 6: Create the quotesDeclarativeAgent.json File We need to create theÂ agent manifest fileÂ which defines how the declarative agent behaves and interacts with the Breaking Bad API.\nNavigate to:Â appPackage Create a New File:Â Name itÂ quotesDeclarativeAgent.json Add the Following Content:\n{Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json)\u0026#34;,Â \u0026#34;version\u0026#34;:Â \u0026#34;v1.2\u0026#34;,Â \u0026#34;name\u0026#34;:Â \u0026#34;Breaking badquotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;This declarative agent helps you get a random quote from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;instructions\u0026#34;:Â \u0026#34;$[file(\u0026#39;instruction.txt\u0026#39;)]\u0026#34;,Â \u0026#34;conversation_starters\u0026#34;: [Â {Â \u0026#34;text\u0026#34;:Â \u0026#34;Give me a random quote from Breaking Bad with author name?\u0026#34;Â } ],Â \u0026#34;actions\u0026#34;: [Â {Â \u0026#34;id\u0026#34;:Â \u0026#34;quoteplugin\u0026#34;,Â \u0026#34;file\u0026#34;:Â \u0026#34;ai-plugin.json\u0026#34;Â }Â ]Â } Step 7: Update the instructions.txt File The instructions.txt file plays a crucial role in declarative agent setup. It defines how the agent should behave, respond to user queries, and interact with the Breaking Bad API. This make sures that the agent stays focused on its purpose and maintains a consistent user experience.\nUpdate it with the Following Content:\nYou are an assistant specialized in retrieving quotes from the provided API, ensuring a smooth and delightful user experience. Your responses should include the quote and its author.Â Guidelines:Â - Exclusive API Use: Do not perform web searches; rely solely on the provided API for data retrieval. Do not proceess any other request. This is solely for breaking bad quotes nothing else, keep in mind!Â - Response Format: Present the quote followed by the author\u0026#39;s name.Â - Error Handling: If the API does not return a quote, respond with: \u0026#34;I\u0026#39;m sorry, I couldn\u0026#39;t retrieve a quote at this moment.\u0026#34;Â - User Interaction: Maintain a friendly and engaging tone to ensure a delightful user experience. Showcase: The Final Outcome of All Efforts To run and debug your declarative agent, click on theÂ Run and DebugÂ icon inÂ VS Code, which can be found on the left sidebar. The process will take approximatelyÂ ~10-15 minutesÂ to initialize. During this time, a sign-in prompt will appear where youâ€™ll need to log in with yourÂ Microsoft 365 accountÂ credentials.\nOnce signed in, if you are not automatically redirected, you can manually visitÂ office.com/chat?auth=2Â to access the Copilot interface.\nSelect the prompt we defined earlier, and it will prompt you to process the query. Click on Always Allow to proceed.\nFinal Output:\nHow to Verify if It\u0026rsquo;s Working and Fetching Data from the API\nVerify via Localhost: Open the terminal in VS Code and click on Start Backend. Once it\u0026rsquo;s running, you\u0026rsquo;ll see the local host URL, which should begin with localhost:7071/api/quotes. Open this URL in your browser, and it will return a JSON response with the quote data. Verify via Agent Request: Another way to check is by sending a request from the agent. This will invoke the getQuote function, which generates a unique ID each time. The response will include text indicating that the function was programmatically called. Bonus: How does the breaking bad quotes agent work? When a user requests a Breaking Bad quote in Microsoft 365 Copilot, the agent works in a few simple steps:Â Manifest Check:Â The agent starts by checking its task list in theÂ manifest file API Connection:Â It then refers to theÂ API specificationÂ to understand how to connect to the Breaking Bad API Data Fetch:Â The agent sends a request to anÂ Azure Function, which fetches a random quote and the authorâ€™s name from the API Data Return:Â The quote and author are returned in a structured JSON format User Display:Â Finally, the agent displays the quote clearly in the Copilot interface Conclusion Itâ€™s been a bit of a ride, hasnâ€™t it? But hey, weâ€™ve finally done it! We have successfully created a declarative agent using the Breaking Bad API, but the process can be applied to any API, including those requiring authentication with API key or OAuth.\nif you hit any bumps along the way, donâ€™t hesitate to drop a comment below. If you found this helpful, give it a thumbs up or click on your favorite emoji button below. Good luck, and happy coding!\nAppendix\nThis post is inspired by the following resources:\nIntroducing New Agents in Microsoft 365 Extending Copilot for Microsoft 365 Workshop on Building Declarative Agents for Microsoft 365 Copilot Breaking Bad Quotes API Breaking Bad Icon by Icons8 ","permalink":"http://localhost:1313/blog/2025/january/create-a-custom-declarative-agent-with-breaking-bad-api/","summary":"\u003cp\u003eBack inÂ November 2024, Microsoft introduced newÂ \u003ca href=\"https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918?utm_source=chatgpt.com\"\u003eAI-powered agents\u003c/a\u003eÂ in Microsoft 365 Copilot.Â Â \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/overview-declarative-agent\"\u003eDeclarative agents\u003c/a\u003eÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â \u003c/p\u003e","title":"Create a Custom Declarative Agent with Breaking Bad API"},{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below example shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"},{"content":"Back inÂ November 2024, Microsoft introduced newÂ AI-powered agentsÂ in Microsoft 365 Copilot.Â Declarative agentsÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â Today, we will create a custom declarative agent using an open-source API to demonstrate how agents can interact with external data sources.\nOpen Source API Overview:\nWe\u0026rsquo;ll be using theÂ Breaking Bad API, an open-source API that provides quotes from the popular TV seriesÂ Breaking Bad. The API response will return a quote along with the author\u0026rsquo;s name (character name) from the series.\nSample\nLetâ€™s get started!\nStep 1: Creating a Custom Declarative Agent Using Microsoft Toolkit Extension Let\u0026rsquo;s begin by creating a custom declarative agent using the Microsoft Toolkit extension. Follow these step-by-step instructions to set up your agent:Â Launch the Microsoft Toolkit Extension and click on Create a New App under Create a Project or Explore Samples Choose Agent as your app type Select Declarative Agent to build an agent powered by Microsoft 365 Copilot Click Add Plugin to connect external APIs to your agent Choose Start with a New API to set up a fresh connection for your agent Pick None for authentication since the Breaking Bad API doesnâ€™t require it Opt for TypeScript as programming language for a smoother experience Select a folder to store project files (pro tip: avoid saving it in the C drive for better organization) Finally, give your agent a name like BreakingBad Agent and hit the setup button Wohooo!Â ðŸŽ‰Â You\u0026rsquo;ve Successfully Created Your Declarative Agent with an API Plugin! After completing the setup, a new window will pop up inÂ VS CodeÂ with your project structure ready. But waitâ€”there\u0026rsquo;s more!Â By default, the project folder includes a demo API plugin. However, this plugin uses a local json file as its data source. Since we want to fetch real-time data from an actual API, we will need to remove the existing demo setup.\nClean Up the Default Files\nNow that your declarative agent is set up, it\u0026rsquo;s time to remove the default files that use local data. Since we will be working with a live API instead, delete the following files from your project directory:Â appPackage \u0026gt; apiSpecificationfile \u0026gt; repair.ymlÂ appPackage \u0026gt; repairDeclarativeAgent.jsonÂ src \u0026gt; RepairsData.jsonÂ src \u0026gt; functions \u0026gt; repairs.ts\nDonâ€™t worry about the files we just deleted. Weâ€™re going to create the essential files needed for ourÂ Breaking Bad AgentÂ from scratch. Up next, weâ€™ll fetch real-time data directly from the API and configure the agent to use it.\nStep 2: Create a New Function File for the Breaking Bad API Integration Next, we need to create a new file where our agent will interact with theÂ Breaking Bad API.Â Navigate to:Â src \u0026gt; functions Create a New File:Â Name itÂ quotes.ts Now, copy and paste the following code intoÂ quotes.ts. This function will act as anÂ Azure FunctionÂ responsible for sending requests and receiving quotes from the live Breaking Bad API.\nimportÂ {Â app,Â HttpResponseInitÂ }Â fromÂ \u0026#34;@azure/functions\u0026#34;;Â exportÂ asyncÂ functionÂ quotes():Â Promise\u0026lt;HttpResponseInit\u0026gt; {Â constÂ breakingbadResponseÂ =Â awaitÂ fetch(\u0026#39;https://api.breakingbadquotes.xyz/v1/quotes\u0026#39;);Â constÂ breakingbadDataÂ =Â awaitÂ breakingbadResponse.json();Â returnÂ {Â status:Â 200,Â jsonBody:Â {Â quotes:Â breakingbadData,Â },Â };Â }Â app.http(\u0026#34;quotes\u0026#34;, {Â methods:Â [\u0026#34;GET\u0026#34;],Â authLevel:Â \u0026#34;anonymous\u0026#34;,Â handler:Â quotes,Â }); If you encounter the error Cannot find module '@azure/functions' or its corresponding type, donâ€™t worry! This is a common issue, and the required modules will be automatically installed when you run the agent for the first time.\nStep 3: Create the API Specification File Now, let\u0026rsquo;s create the API specification file that will define how the declarative agent interacts with theÂ Breaking Bad API.\nNavigate to:Â appPackage \u0026gt; apiSpecificationfile Create a New File:Â Name itÂ quotes.yml openapi:Â 3.0.0Â info:Â title:Â Breaking bad Quote APIÂ description:Â Random Quote api from the Breaking Bad TV series with authorÂ version:Â 1.0.0Â servers:Â -Â url:Â ${{OPENAPI_SERVER_URL}}/apiÂ description:Â The quotes api serverÂ paths:Â /quotes:Â get:Â operationId:Â getQuotesÂ summary:Â get all breaking bad quotes with authorÂ description:Â Returns a single random quote from the Breaking Bad TV series with authorÂ responses:Â \u0026#39;200\u0026#39;:Â description:Â A random quote from the Breaking Bad TV series with authorÂ content:Â application/json:Â schema:Â type:Â objectÂ properties:Â results:Â type:Â arrayÂ items:Â type:Â objectÂ properties:Â quote:Â type:Â stringÂ description:Â Breaking bad quote with authorÂ author:Â type:Â stringÂ description:Â The author name of the quote Step 4: Update theÂ ai-plugin.jsonÂ File Now, let\u0026rsquo;s update the ai-plugin.json file so that the declarative agent is properly linked with the Breaking Bad API and the Azure Function.Â Navigate to:Â appPackage.Â Open the File: OpenÂ ai-plugin.json Remove:Â The \u0026quot;Static_template\u0026quot; entry Update:Â The runtimes URL and the function name as shown below: {Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json)\u0026#34;,Â \u0026#34;schema_version\u0026#34;:Â \u0026#34;v2.2\u0026#34;,Â \u0026#34;namespace\u0026#34;:Â \u0026#34;Breakingbadquotes\u0026#34;,Â \u0026#34;name_for_human\u0026#34;:Â \u0026#34;Breakingbadquotes Plugin\u0026#34;,Â \u0026#34;description_for_human\u0026#34;:Â \u0026#34;Generate random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;description_for_model\u0026#34;:Â \u0026#34;Plugin for generating random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;functions\u0026#34;: [Â {Â \u0026#34;name\u0026#34;:Â \u0026#34;getQuotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;Returns a random quote with author from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;response_semantics\u0026#34;: {Â \u0026#34;data_path\u0026#34;:Â \u0026#34;$.quotes\u0026#34;,Â \u0026#34;properties\u0026#34;: {Â \u0026#34;title\u0026#34;:Â \u0026#34;$.quote\u0026#34;,Â \u0026#34;subtitle\u0026#34;:Â \u0026#34;$.author\u0026#34;Â }Â }Â }Â } ],Â \u0026#34;runtimes\u0026#34;: [Â {Â \u0026#34;type\u0026#34;:Â \u0026#34;OpenApi\u0026#34;,Â \u0026#34;auth\u0026#34;: {Â \u0026#34;type\u0026#34;:Â \u0026#34;None\u0026#34;Â },Â \u0026#34;spec\u0026#34;: {Â \u0026#34;url\u0026#34;:Â \u0026#34;apiSpecificationFile/quotes.yml\u0026#34;,Â \u0026#34;progress_style\u0026#34;:Â \u0026#34;ShowUsageWithInputAndOutput\u0026#34;Â },Â \u0026#34;run_for_functions\u0026#34;: [\u0026#34;getQuotes\u0026#34;]Â }Â ],Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;conversation_starters\u0026#34;: []Â }Â } Step 5: Update the manifest.json File The manifest.json file serves as the app manifest for your declarative agent. It is specifying the agentâ€™s identity and the declarative agent configuration files. We\u0026rsquo;ll update it to reflect the Breaking Bad agent setup.\nNavigate to:Â appPackage Open the File:Â openÂ manifest.json Update:Â The \u0026quot;copilotAgents\u0026quot; section as shown below: You can also update the icon of your application in the same file. First, download any image and make sure it\u0026rsquo;s 192x192 pixels. Replace the existing icon with your new image by saving it as color.png in your project folder. If you choose to change the name of the image, make sure to update it in the application manifest.json file.\n{Â \u0026#34;copilotAgents\u0026#34;: {Â \u0026#34;declarativeAgents\u0026#34;: [Â {Â \u0026#34;id\u0026#34;: \u0026#34;breakingBadDeclarativeAgent\u0026#34;,Â \u0026#34;file\u0026#34;: \u0026#34;breakingBadDeclarativeAgent.json\u0026#34;Â }Â ]Â }Â } Step 6: Create the quotesDeclarativeAgent.json File We need to create theÂ agent manifest fileÂ which defines how the declarative agent behaves and interacts with the Breaking Bad API.\nNavigate to:Â appPackage Create a New File:Â Name itÂ quotesDeclarativeAgent.json Add the Following Content:\n{Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json)\u0026#34;,Â \u0026#34;version\u0026#34;:Â \u0026#34;v1.2\u0026#34;,Â \u0026#34;name\u0026#34;:Â \u0026#34;Breaking badquotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;This declarative agent helps you get a random quote from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;instructions\u0026#34;:Â \u0026#34;$[file(\u0026#39;instruction.txt\u0026#39;)]\u0026#34;,Â \u0026#34;conversation_starters\u0026#34;: [Â {Â \u0026#34;text\u0026#34;:Â \u0026#34;Give me a random quote from Breaking Bad with author name?\u0026#34;Â } ],Â \u0026#34;actions\u0026#34;: [Â {Â \u0026#34;id\u0026#34;:Â \u0026#34;quoteplugin\u0026#34;,Â \u0026#34;file\u0026#34;:Â \u0026#34;ai-plugin.json\u0026#34;Â }Â ]Â } Step 7: Update the instructions.txt File The instructions.txt file plays a crucial role in declarative agent setup. It defines how the agent should behave, respond to user queries, and interact with the Breaking Bad API. This make sures that the agent stays focused on its purpose and maintains a consistent user experience.\nUpdate it with the Following Content:\nYou are an assistant specialized in retrieving quotes from the provided API, ensuring a smooth and delightful user experience. Your responses should include the quote and its author.Â Guidelines:Â - Exclusive API Use: Do not perform web searches; rely solely on the provided API for data retrieval. Do not proceess any other request. This is solely for breaking bad quotes nothing else, keep in mind!Â - Response Format: Present the quote followed by the author\u0026#39;s name.Â - Error Handling: If the API does not return a quote, respond with: \u0026#34;I\u0026#39;m sorry, I couldn\u0026#39;t retrieve a quote at this moment.\u0026#34;Â - User Interaction: Maintain a friendly and engaging tone to ensure a delightful user experience. Showcase: The Final Outcome of All Efforts To run and debug your declarative agent, click on theÂ Run and DebugÂ icon inÂ VS Code, which can be found on the left sidebar. The process will take approximatelyÂ ~10-15 minutesÂ to initialize. During this time, a sign-in prompt will appear where youâ€™ll need to log in with yourÂ Microsoft 365 accountÂ credentials.\nOnce signed in, if you are not automatically redirected, you can manually visitÂ office.com/chat?auth=2Â to access the Copilot interface.\nSelect the prompt we defined earlier, and it will prompt you to process the query. Click on Always Allow to proceed.\nFinal Output:\nHow to Verify if It\u0026rsquo;s Working and Fetching Data from the API\nVerify via Localhost: Open the terminal in VS Code and click on Start Backend. Once it\u0026rsquo;s running, you\u0026rsquo;ll see the local host URL, which should begin with localhost:7071/api/quotes. Open this URL in your browser, and it will return a JSON response with the quote data. Verify via Agent Request: Another way to check is by sending a request from the agent. This will invoke the getQuote function, which generates a unique ID each time. The response will include text indicating that the function was programmatically called. Bonus: How does the breaking bad quotes agent work? When a user requests a Breaking Bad quote in Microsoft 365 Copilot, the agent works in a few simple steps:Â Manifest Check:Â The agent starts by checking its task list in theÂ manifest file API Connection:Â It then refers to theÂ API specificationÂ to understand how to connect to the Breaking Bad API Data Fetch:Â The agent sends a request to anÂ Azure Function, which fetches a random quote and the authorâ€™s name from the API Data Return:Â The quote and author are returned in a structured JSON format User Display:Â Finally, the agent displays the quote clearly in the Copilot interface Conclusion Itâ€™s been a bit of a ride, hasnâ€™t it? But hey, weâ€™ve finally done it! We have successfully created a declarative agent using the Breaking Bad API, but the process can be applied to any API, including those requiring authentication with API key or OAuth.\nif you hit any bumps along the way, donâ€™t hesitate to drop a comment below. If you found this helpful, give it a thumbs up or click on your favorite emoji button below. Good luck, and happy coding!\nAppendix\nThis post is inspired by the following resources:\nIntroducing New Agents in Microsoft 365 Extending Copilot for Microsoft 365 Workshop on Building Declarative Agents for Microsoft 365 Copilot Breaking Bad Quotes API Breaking Bad Icon by Icons8 ","permalink":"http://localhost:1313/blog/2025/january/create-a-custom-declarative-agent-with-breaking-bad-api/","summary":"\u003cp\u003eBack inÂ November 2024, Microsoft introduced newÂ \u003ca href=\"https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918?utm_source=chatgpt.com\"\u003eAI-powered agents\u003c/a\u003eÂ in Microsoft 365 Copilot.Â Â \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/overview-declarative-agent\"\u003eDeclarative agents\u003c/a\u003eÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â \u003c/p\u003e","title":"Create a Custom Declarative Agent with Breaking Bad API"},{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below example shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"},{"content":"Back inÂ November 2024, Microsoft introduced newÂ AI-powered agentsÂ in Microsoft 365 Copilot.Â Declarative agentsÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â Today, we will create a custom declarative agent using an open-source API to demonstrate how agents can interact with external data sources.\nOpen Source API Overview:\nWe\u0026rsquo;ll be using theÂ Breaking Bad API, an open-source API that provides quotes from the popular TV seriesÂ Breaking Bad. The API response will return a quote along with the author\u0026rsquo;s name (character name) from the series.\nSample Response\nLetâ€™s get started!\nStep 1: Creating a Custom Declarative Agent Using Microsoft Toolkit Extension Let\u0026rsquo;s begin by creating a custom declarative agent using the Microsoft Toolkit extension. Follow these step-by-step instructions to set up your agent:Â Launch the Microsoft Toolkit Extension and click on Create a New App under Create a Project or Explore Samples Choose Agent as your app type Select Declarative Agent to build an agent powered by Microsoft 365 Copilot Click Add Plugin to connect external APIs to your agent Choose Start with a New API to set up a fresh connection for your agent Pick None for authentication since the Breaking Bad API doesnâ€™t require it Opt for TypeScript as programming language for a smoother experience Select a folder to store project files (pro tip: avoid saving it in the C drive for better organization) Finally, give your agent a name like BreakingBad Agent and hit the setup button Wohooo!Â ðŸŽ‰Â You\u0026rsquo;ve Successfully Created Your Declarative Agent with an API Plugin! After completing the setup, a new window will pop up inÂ VS CodeÂ with your project structure ready. But waitâ€”there\u0026rsquo;s more!Â By default, the project folder includes a demo API plugin. However, this plugin uses a local json file as its data source. Since we want to fetch real-time data from an actual API, we will need to remove the existing demo setup.\nClean Up the Default Files\nNow that your declarative agent is set up, it\u0026rsquo;s time to remove the default files that use local data. Since we will be working with a live API instead, delete the following files from your project directory:Â appPackage \u0026gt; apiSpecificationfile \u0026gt; repair.ymlÂ appPackage \u0026gt; repairDeclarativeAgent.jsonÂ src \u0026gt; RepairsData.jsonÂ src \u0026gt; functions \u0026gt; repairs.ts\nDonâ€™t worry about the files we just deleted. Weâ€™re going to create the essential files needed for ourÂ Breaking Bad AgentÂ from scratch. Up next, weâ€™ll fetch real-time data directly from the API and configure the agent to use it.\nStep 2: Create a New Function File for the Breaking Bad API Integration Next, we need to create a new file where our agent will interact with theÂ Breaking Bad API.Â Navigate to:Â src \u0026gt; functions Create a New File:Â Name itÂ quotes.ts Now, copy and paste the following code intoÂ quotes.ts. This function will act as anÂ Azure FunctionÂ responsible for sending requests and receiving quotes from the live Breaking Bad API.\nimportÂ {Â app,Â HttpResponseInitÂ }Â fromÂ \u0026#34;@azure/functions\u0026#34;;Â exportÂ asyncÂ functionÂ quotes():Â Promise\u0026lt;HttpResponseInit\u0026gt; {Â constÂ breakingbadResponseÂ =Â awaitÂ fetch(\u0026#39;https://api.breakingbadquotes.xyz/v1/quotes\u0026#39;);Â constÂ breakingbadDataÂ =Â awaitÂ breakingbadResponse.json();Â returnÂ {Â status:Â 200,Â jsonBody:Â {Â quotes:Â breakingbadData,Â },Â };Â }Â app.http(\u0026#34;quotes\u0026#34;, {Â methods:Â [\u0026#34;GET\u0026#34;],Â authLevel:Â \u0026#34;anonymous\u0026#34;,Â handler:Â quotes,Â }); If you encounter the error Cannot find module '@azure/functions' or its corresponding type, donâ€™t worry! This is a common issue, and the required modules will be automatically installed when you run the agent for the first time.\nStep 3: Create the API Specification File Now, let\u0026rsquo;s create the API specification file that will define how the declarative agent interacts with theÂ Breaking Bad API.\nNavigate to:Â appPackage \u0026gt; apiSpecificationfile Create a New File:Â Name itÂ quotes.yml openapi:Â 3.0.0Â info:Â title:Â Breaking bad Quote APIÂ description:Â Random Quote api from the Breaking Bad TV series with authorÂ version:Â 1.0.0Â servers:Â -Â url:Â ${{OPENAPI_SERVER_URL}}/apiÂ description:Â The quotes api serverÂ paths:Â /quotes:Â get:Â operationId:Â getQuotesÂ summary:Â get all breaking bad quotes with authorÂ description:Â Returns a single random quote from the Breaking Bad TV series with authorÂ responses:Â \u0026#39;200\u0026#39;:Â description:Â A random quote from the Breaking Bad TV series with authorÂ content:Â application/json:Â schema:Â type:Â objectÂ properties:Â results:Â type:Â arrayÂ items:Â type:Â objectÂ properties:Â quote:Â type:Â stringÂ description:Â Breaking bad quote with authorÂ author:Â type:Â stringÂ description:Â The author name of the quote Step 4: Update theÂ ai-plugin.jsonÂ File Now, let\u0026rsquo;s update the ai-plugin.json file so that the declarative agent is properly linked with the Breaking Bad API and the Azure Function.Â Navigate to:Â appPackage.Â Open the File: OpenÂ ai-plugin.json Remove:Â The \u0026quot;Static_template\u0026quot; entry Update:Â The runtimes URL and the function name as shown below: {Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json)\u0026#34;,Â \u0026#34;schema_version\u0026#34;:Â \u0026#34;v2.2\u0026#34;,Â \u0026#34;namespace\u0026#34;:Â \u0026#34;Breakingbadquotes\u0026#34;,Â \u0026#34;name_for_human\u0026#34;:Â \u0026#34;Breakingbadquotes Plugin\u0026#34;,Â \u0026#34;description_for_human\u0026#34;:Â \u0026#34;Generate random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;description_for_model\u0026#34;:Â \u0026#34;Plugin for generating random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;functions\u0026#34;: [Â {Â \u0026#34;name\u0026#34;:Â \u0026#34;getQuotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;Returns a random quote with author from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;response_semantics\u0026#34;: {Â \u0026#34;data_path\u0026#34;:Â \u0026#34;$.quotes\u0026#34;,Â \u0026#34;properties\u0026#34;: {Â \u0026#34;title\u0026#34;:Â \u0026#34;$.quote\u0026#34;,Â \u0026#34;subtitle\u0026#34;:Â \u0026#34;$.author\u0026#34;Â }Â }Â }Â } ],Â \u0026#34;runtimes\u0026#34;: [Â {Â \u0026#34;type\u0026#34;:Â \u0026#34;OpenApi\u0026#34;,Â \u0026#34;auth\u0026#34;: {Â \u0026#34;type\u0026#34;:Â \u0026#34;None\u0026#34;Â },Â \u0026#34;spec\u0026#34;: {Â \u0026#34;url\u0026#34;:Â \u0026#34;apiSpecificationFile/quotes.yml\u0026#34;,Â \u0026#34;progress_style\u0026#34;:Â \u0026#34;ShowUsageWithInputAndOutput\u0026#34;Â },Â \u0026#34;run_for_functions\u0026#34;: [\u0026#34;getQuotes\u0026#34;]Â }Â ],Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;conversation_starters\u0026#34;: []Â }Â } Step 5: Update the manifest.json File The manifest.json file serves as the app manifest for your declarative agent. It is specifying the agentâ€™s identity and the declarative agent configuration files. We\u0026rsquo;ll update it to reflect the Breaking Bad agent setup.\nNavigate to:Â appPackage Open the File:Â openÂ manifest.json Update:Â The \u0026quot;copilotAgents\u0026quot; section as shown below: You can also update the icon of your application in the same file. First, download any image and make sure it\u0026rsquo;s 192x192 pixels. Replace the existing icon with your new image by saving it as color.png in your project folder. If you choose to change the name of the image, make sure to update it in the application manifest.json file.\n{Â \u0026#34;copilotAgents\u0026#34;: {Â \u0026#34;declarativeAgents\u0026#34;: [Â {Â \u0026#34;id\u0026#34;: \u0026#34;breakingBadDeclarativeAgent\u0026#34;,Â \u0026#34;file\u0026#34;: \u0026#34;breakingBadDeclarativeAgent.json\u0026#34;Â }Â ]Â }Â } Step 6: Create the quotesDeclarativeAgent.json File We need to create theÂ agent manifest fileÂ which defines how the declarative agent behaves and interacts with the Breaking Bad API.\nNavigate to:Â appPackage Create a New File:Â Name itÂ quotesDeclarativeAgent.json Add the Following Content:\n{Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json)\u0026#34;,Â \u0026#34;version\u0026#34;:Â \u0026#34;v1.2\u0026#34;,Â \u0026#34;name\u0026#34;:Â \u0026#34;Breaking badquotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;This declarative agent helps you get a random quote from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;instructions\u0026#34;:Â \u0026#34;$[file(\u0026#39;instruction.txt\u0026#39;)]\u0026#34;,Â \u0026#34;conversation_starters\u0026#34;: [Â {Â \u0026#34;text\u0026#34;:Â \u0026#34;Give me a random quote from Breaking Bad with author name?\u0026#34;Â } ],Â \u0026#34;actions\u0026#34;: [Â {Â \u0026#34;id\u0026#34;:Â \u0026#34;quoteplugin\u0026#34;,Â \u0026#34;file\u0026#34;:Â \u0026#34;ai-plugin.json\u0026#34;Â }Â ]Â } Step 7: Update the instructions.txt File The instructions.txt file plays a crucial role in declarative agent setup. It defines how the agent should behave, respond to user queries, and interact with the Breaking Bad API. This make sures that the agent stays focused on its purpose and maintains a consistent user experience.\nUpdate it with the Following Content:\nYou are an assistant specialized in retrieving quotes from the provided API, ensuring a smooth and delightful user experience. Your responses should include the quote and its author.Â Guidelines:Â - Exclusive API Use: Do not perform web searches; rely solely on the provided API for data retrieval. Do not proceess any other request. This is solely for breaking bad quotes nothing else, keep in mind!Â - Response Format: Present the quote followed by the author\u0026#39;s name.Â - Error Handling: If the API does not return a quote, respond with: \u0026#34;I\u0026#39;m sorry, I couldn\u0026#39;t retrieve a quote at this moment.\u0026#34;Â - User Interaction: Maintain a friendly and engaging tone to ensure a delightful user experience. Showcase: The Final Outcome of All Efforts To run and debug your declarative agent, click on theÂ Run and DebugÂ icon inÂ VS Code, which can be found on the left sidebar. The process will take approximatelyÂ ~10-15 minutesÂ to initialize. During this time, a sign-in prompt will appear where youâ€™ll need to log in with yourÂ Microsoft 365 accountÂ credentials.\nOnce signed in, if you are not automatically redirected, you can manually visitÂ office.com/chat?auth=2Â to access the Copilot interface.\nSelect the prompt we defined earlier, and it will prompt you to process the query. Click on Always Allow to proceed.\nFinal Output:\nHow to Verify if It\u0026rsquo;s Working and Fetching Data from the API\nVerify via Localhost: Open the terminal in VS Code and click on Start Backend. Once it\u0026rsquo;s running, you\u0026rsquo;ll see the local host URL, which should begin with localhost:7071/api/quotes. Open this URL in your browser, and it will return a JSON response with the quote data. Verify via Agent Request: Another way to check is by sending a request from the agent. This will invoke the getQuote function, which generates a unique ID each time. The response will include text indicating that the function was programmatically called. Bonus: How does the breaking bad quotes agent work? When a user requests a Breaking Bad quote in Microsoft 365 Copilot, the agent works in a few simple steps:Â Manifest Check:Â The agent starts by checking its task list in theÂ manifest file API Connection:Â It then refers to theÂ API specificationÂ to understand how to connect to the Breaking Bad API Data Fetch:Â The agent sends a request to anÂ Azure Function, which fetches a random quote and the authorâ€™s name from the API Data Return:Â The quote and author are returned in a structured JSON format User Display:Â Finally, the agent displays the quote clearly in the Copilot interface Conclusion Itâ€™s been a bit of a ride, hasnâ€™t it? But hey, weâ€™ve finally done it! We have successfully created a declarative agent using the Breaking Bad API, but the process can be applied to any API, including those requiring authentication with API key or OAuth.\nif you hit any bumps along the way, donâ€™t hesitate to drop a comment below. If you found this helpful, give it a thumbs up or click on your favorite emoji button below. Good luck, and happy coding!\nAppendix\nThis post is inspired by the following resources:\nIntroducing New Agents in Microsoft 365 Extending Copilot for Microsoft 365 Workshop on Building Declarative Agents for Microsoft 365 Copilot Breaking Bad Quotes API Breaking Bad Icon by Icons8 ","permalink":"http://localhost:1313/blog/2025/january/create-a-custom-declarative-agent-with-breaking-bad-api/","summary":"\u003cp\u003eBack inÂ November 2024, Microsoft introduced newÂ \u003ca href=\"https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918?utm_source=chatgpt.com\"\u003eAI-powered agents\u003c/a\u003eÂ in Microsoft 365 Copilot.Â Â \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/overview-declarative-agent\"\u003eDeclarative agents\u003c/a\u003eÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â \u003c/p\u003e","title":"Create a Custom Declarative Agent with Breaking Bad API"},{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below example shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"},{"content":"Back inÂ November 2024, Microsoft introduced newÂ AI-powered agentsÂ in Microsoft 365 Copilot.Â Declarative agentsÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â Today, we will create a custom declarative agent using an open-source API to demonstrate how agents can interact with external data sources.\nOpen Source API Overview:\nWe\u0026rsquo;ll be using theÂ Breaking Bad API, an open-source API that provides quotes from the popular TV seriesÂ Breaking Bad. The API response will return a quote along with the author\u0026rsquo;s name (character name) from the series.\nSample Response from AP\nLetâ€™s get started!\nStep 1: Creating a Custom Declarative Agent Using Microsoft Toolkit Extension Let\u0026rsquo;s begin by creating a custom declarative agent using the Microsoft Toolkit extension. Follow these step-by-step instructions to set up your agent:Â Launch the Microsoft Toolkit Extension and click on Create a New App under Create a Project or Explore Samples Choose Agent as your app type Select Declarative Agent to build an agent powered by Microsoft 365 Copilot Click Add Plugin to connect external APIs to your agent Choose Start with a New API to set up a fresh connection for your agent Pick None for authentication since the Breaking Bad API doesnâ€™t require it Opt for TypeScript as programming language for a smoother experience Select a folder to store project files (pro tip: avoid saving it in the C drive for better organization) Finally, give your agent a name like BreakingBad Agent and hit the setup button Wohooo!Â ðŸŽ‰Â You\u0026rsquo;ve Successfully Created Your Declarative Agent with an API Plugin! After completing the setup, a new window will pop up inÂ VS CodeÂ with your project structure ready. But waitâ€”there\u0026rsquo;s more!Â By default, the project folder includes a demo API plugin. However, this plugin uses a local json file as its data source. Since we want to fetch real-time data from an actual API, we will need to remove the existing demo setup.\nClean Up the Default Files\nNow that your declarative agent is set up, it\u0026rsquo;s time to remove the default files that use local data. Since we will be working with a live API instead, delete the following files from your project directory:Â appPackage \u0026gt; apiSpecificationfile \u0026gt; repair.ymlÂ appPackage \u0026gt; repairDeclarativeAgent.jsonÂ src \u0026gt; RepairsData.jsonÂ src \u0026gt; functions \u0026gt; repairs.ts\nDonâ€™t worry about the files we just deleted. Weâ€™re going to create the essential files needed for ourÂ Breaking Bad AgentÂ from scratch. Up next, weâ€™ll fetch real-time data directly from the API and configure the agent to use it.\nStep 2: Create a New Function File for the Breaking Bad API Integration Next, we need to create a new file where our agent will interact with theÂ Breaking Bad API.Â Navigate to:Â src \u0026gt; functions Create a New File:Â Name itÂ quotes.ts Now, copy and paste the following code intoÂ quotes.ts. This function will act as anÂ Azure FunctionÂ responsible for sending requests and receiving quotes from the live Breaking Bad API.\nimportÂ {Â app,Â HttpResponseInitÂ }Â fromÂ \u0026#34;@azure/functions\u0026#34;;Â exportÂ asyncÂ functionÂ quotes():Â Promise\u0026lt;HttpResponseInit\u0026gt; {Â constÂ breakingbadResponseÂ =Â awaitÂ fetch(\u0026#39;https://api.breakingbadquotes.xyz/v1/quotes\u0026#39;);Â constÂ breakingbadDataÂ =Â awaitÂ breakingbadResponse.json();Â returnÂ {Â status:Â 200,Â jsonBody:Â {Â quotes:Â breakingbadData,Â },Â };Â }Â app.http(\u0026#34;quotes\u0026#34;, {Â methods:Â [\u0026#34;GET\u0026#34;],Â authLevel:Â \u0026#34;anonymous\u0026#34;,Â handler:Â quotes,Â }); If you encounter the error Cannot find module '@azure/functions' or its corresponding type, donâ€™t worry! This is a common issue, and the required modules will be automatically installed when you run the agent for the first time.\nStep 3: Create the API Specification File Now, let\u0026rsquo;s create the API specification file that will define how the declarative agent interacts with theÂ Breaking Bad API.\nNavigate to:Â appPackage \u0026gt; apiSpecificationfile Create a New File:Â Name itÂ quotes.yml openapi:Â 3.0.0Â info:Â title:Â Breaking bad Quote APIÂ description:Â Random Quote api from the Breaking Bad TV series with authorÂ version:Â 1.0.0Â servers:Â -Â url:Â ${{OPENAPI_SERVER_URL}}/apiÂ description:Â The quotes api serverÂ paths:Â /quotes:Â get:Â operationId:Â getQuotesÂ summary:Â get all breaking bad quotes with authorÂ description:Â Returns a single random quote from the Breaking Bad TV series with authorÂ responses:Â \u0026#39;200\u0026#39;:Â description:Â A random quote from the Breaking Bad TV series with authorÂ content:Â application/json:Â schema:Â type:Â objectÂ properties:Â results:Â type:Â arrayÂ items:Â type:Â objectÂ properties:Â quote:Â type:Â stringÂ description:Â Breaking bad quote with authorÂ author:Â type:Â stringÂ description:Â The author name of the quote Step 4: Update theÂ ai-plugin.jsonÂ File Now, let\u0026rsquo;s update the ai-plugin.json file so that the declarative agent is properly linked with the Breaking Bad API and the Azure Function.Â Navigate to:Â appPackage.Â Open the File: OpenÂ ai-plugin.json Remove:Â The \u0026quot;Static_template\u0026quot; entry Update:Â The runtimes URL and the function name as shown below: {Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json)\u0026#34;,Â \u0026#34;schema_version\u0026#34;:Â \u0026#34;v2.2\u0026#34;,Â \u0026#34;namespace\u0026#34;:Â \u0026#34;Breakingbadquotes\u0026#34;,Â \u0026#34;name_for_human\u0026#34;:Â \u0026#34;Breakingbadquotes Plugin\u0026#34;,Â \u0026#34;description_for_human\u0026#34;:Â \u0026#34;Generate random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;description_for_model\u0026#34;:Â \u0026#34;Plugin for generating random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;functions\u0026#34;: [Â {Â \u0026#34;name\u0026#34;:Â \u0026#34;getQuotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;Returns a random quote with author from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;response_semantics\u0026#34;: {Â \u0026#34;data_path\u0026#34;:Â \u0026#34;$.quotes\u0026#34;,Â \u0026#34;properties\u0026#34;: {Â \u0026#34;title\u0026#34;:Â \u0026#34;$.quote\u0026#34;,Â \u0026#34;subtitle\u0026#34;:Â \u0026#34;$.author\u0026#34;Â }Â }Â }Â } ],Â \u0026#34;runtimes\u0026#34;: [Â {Â \u0026#34;type\u0026#34;:Â \u0026#34;OpenApi\u0026#34;,Â \u0026#34;auth\u0026#34;: {Â \u0026#34;type\u0026#34;:Â \u0026#34;None\u0026#34;Â },Â \u0026#34;spec\u0026#34;: {Â \u0026#34;url\u0026#34;:Â \u0026#34;apiSpecificationFile/quotes.yml\u0026#34;,Â \u0026#34;progress_style\u0026#34;:Â \u0026#34;ShowUsageWithInputAndOutput\u0026#34;Â },Â \u0026#34;run_for_functions\u0026#34;: [\u0026#34;getQuotes\u0026#34;]Â }Â ],Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;conversation_starters\u0026#34;: []Â }Â } Step 5: Update the manifest.json File The manifest.json file serves as the app manifest for your declarative agent. It is specifying the agentâ€™s identity and the declarative agent configuration files. We\u0026rsquo;ll update it to reflect the Breaking Bad agent setup.\nNavigate to:Â appPackage Open the File:Â openÂ manifest.json Update:Â The \u0026quot;copilotAgents\u0026quot; section as shown below: You can also update the icon of your application in the same file. First, download any image and make sure it\u0026rsquo;s 192x192 pixels. Replace the existing icon with your new image by saving it as color.png in your project folder. If you choose to change the name of the image, make sure to update it in the application manifest.json file.\n{Â \u0026#34;copilotAgents\u0026#34;: {Â \u0026#34;declarativeAgents\u0026#34;: [Â {Â \u0026#34;id\u0026#34;: \u0026#34;breakingBadDeclarativeAgent\u0026#34;,Â \u0026#34;file\u0026#34;: \u0026#34;breakingBadDeclarativeAgent.json\u0026#34;Â }Â ]Â }Â } Step 6: Create the quotesDeclarativeAgent.json File We need to create theÂ agent manifest fileÂ which defines how the declarative agent behaves and interacts with the Breaking Bad API.\nNavigate to:Â appPackage Create a New File:Â Name itÂ quotesDeclarativeAgent.json Add the Following Content:\n{Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json)\u0026#34;,Â \u0026#34;version\u0026#34;:Â \u0026#34;v1.2\u0026#34;,Â \u0026#34;name\u0026#34;:Â \u0026#34;Breaking badquotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;This declarative agent helps you get a random quote from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;instructions\u0026#34;:Â \u0026#34;$[file(\u0026#39;instruction.txt\u0026#39;)]\u0026#34;,Â \u0026#34;conversation_starters\u0026#34;: [Â {Â \u0026#34;text\u0026#34;:Â \u0026#34;Give me a random quote from Breaking Bad with author name?\u0026#34;Â } ],Â \u0026#34;actions\u0026#34;: [Â {Â \u0026#34;id\u0026#34;:Â \u0026#34;quoteplugin\u0026#34;,Â \u0026#34;file\u0026#34;:Â \u0026#34;ai-plugin.json\u0026#34;Â }Â ]Â } Step 7: Update the instructions.txt File The instructions.txt file plays a crucial role in declarative agent setup. It defines how the agent should behave, respond to user queries, and interact with the Breaking Bad API. This make sures that the agent stays focused on its purpose and maintains a consistent user experience.\nUpdate it with the Following Content:\nYou are an assistant specialized in retrieving quotes from the provided API, ensuring a smooth and delightful user experience. Your responses should include the quote and its author.Â Guidelines:Â - Exclusive API Use: Do not perform web searches; rely solely on the provided API for data retrieval. Do not proceess any other request. This is solely for breaking bad quotes nothing else, keep in mind!Â - Response Format: Present the quote followed by the author\u0026#39;s name.Â - Error Handling: If the API does not return a quote, respond with: \u0026#34;I\u0026#39;m sorry, I couldn\u0026#39;t retrieve a quote at this moment.\u0026#34;Â - User Interaction: Maintain a friendly and engaging tone to ensure a delightful user experience. Showcase: The Final Outcome of All Efforts To run and debug your declarative agent, click on theÂ Run and DebugÂ icon inÂ VS Code, which can be found on the left sidebar. The process will take approximatelyÂ ~10-15 minutesÂ to initialize. During this time, a sign-in prompt will appear where youâ€™ll need to log in with yourÂ Microsoft 365 accountÂ credentials.\nOnce signed in, if you are not automatically redirected, you can manually visitÂ office.com/chat?auth=2Â to access the Copilot interface.\nSelect the prompt we defined earlier, and it will prompt you to process the query. Click on Always Allow to proceed.\nFinal Output:\nHow to Verify if It\u0026rsquo;s Working and Fetching Data from the API\nVerify via Localhost: Open the terminal in VS Code and click on Start Backend. Once it\u0026rsquo;s running, you\u0026rsquo;ll see the local host URL, which should begin with localhost:7071/api/quotes. Open this URL in your browser, and it will return a JSON response with the quote data. Verify via Agent Request: Another way to check is by sending a request from the agent. This will invoke the getQuote function, which generates a unique ID each time. The response will include text indicating that the function was programmatically called. Bonus: How does the breaking bad quotes agent work? When a user requests a Breaking Bad quote in Microsoft 365 Copilot, the agent works in a few simple steps:Â Manifest Check:Â The agent starts by checking its task list in theÂ manifest file API Connection:Â It then refers to theÂ API specificationÂ to understand how to connect to the Breaking Bad API Data Fetch:Â The agent sends a request to anÂ Azure Function, which fetches a random quote and the authorâ€™s name from the API Data Return:Â The quote and author are returned in a structured JSON format User Display:Â Finally, the agent displays the quote clearly in the Copilot interface Conclusion Itâ€™s been a bit of a ride, hasnâ€™t it? But hey, weâ€™ve finally done it! We have successfully created a declarative agent using the Breaking Bad API, but the process can be applied to any API, including those requiring authentication with API key or OAuth.\nif you hit any bumps along the way, donâ€™t hesitate to drop a comment below. If you found this helpful, give it a thumbs up or click on your favorite emoji button below. Good luck, and happy coding!\nAppendix\nThis post is inspired by the following resources:\nIntroducing New Agents in Microsoft 365 Extending Copilot for Microsoft 365 Workshop on Building Declarative Agents for Microsoft 365 Copilot Breaking Bad Quotes API Breaking Bad Icon by Icons8 ","permalink":"http://localhost:1313/blog/2025/january/create-a-custom-declarative-agent-with-breaking-bad-api/","summary":"\u003cp\u003eBack inÂ November 2024, Microsoft introduced newÂ \u003ca href=\"https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918?utm_source=chatgpt.com\"\u003eAI-powered agents\u003c/a\u003eÂ in Microsoft 365 Copilot.Â Â \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/overview-declarative-agent\"\u003eDeclarative agents\u003c/a\u003eÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â \u003c/p\u003e","title":"Create a Custom Declarative Agent with Breaking Bad API"},{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below example shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"},{"content":"Back inÂ November 2024, Microsoft introduced newÂ AI-powered agentsÂ in Microsoft 365 Copilot.Â Declarative agentsÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â Today, we will create a custom declarative agent using an open-source API to demonstrate how agents can interact with external data sources.\nOpen Source API Overview:\nWe\u0026rsquo;ll be using theÂ Breaking Bad API, an open-source API that provides quotes from the popular TV seriesÂ Breaking Bad. The API response will return a quote along with the author\u0026rsquo;s name (character name) from the series.\nSample Response from API\nLetâ€™s get started!\nStep 1: Creating a Custom Declarative Agent Using Microsoft Toolkit Extension Let\u0026rsquo;s begin by creating a custom declarative agent using the Microsoft Toolkit extension. Follow these step-by-step instructions to set up your agent:Â Launch the Microsoft Toolkit Extension and click on Create a New App under Create a Project or Explore Samples Choose Agent as your app type Select Declarative Agent to build an agent powered by Microsoft 365 Copilot Click Add Plugin to connect external APIs to your agent Choose Start with a New API to set up a fresh connection for your agent Pick None for authentication since the Breaking Bad API doesnâ€™t require it Opt for TypeScript as programming language for a smoother experience Select a folder to store project files (pro tip: avoid saving it in the C drive for better organization) Finally, give your agent a name like BreakingBad Agent and hit the setup button Wohooo!Â ðŸŽ‰Â You\u0026rsquo;ve Successfully Created Your Declarative Agent with an API Plugin! After completing the setup, a new window will pop up inÂ VS CodeÂ with your project structure ready. But waitâ€”there\u0026rsquo;s more!Â By default, the project folder includes a demo API plugin. However, this plugin uses a local json file as its data source. Since we want to fetch real-time data from an actual API, we will need to remove the existing demo setup.\nClean Up the Default Files\nNow that your declarative agent is set up, it\u0026rsquo;s time to remove the default files that use local data. Since we will be working with a live API instead, delete the following files from your project directory:Â appPackage \u0026gt; apiSpecificationfile \u0026gt; repair.ymlÂ appPackage \u0026gt; repairDeclarativeAgent.jsonÂ src \u0026gt; RepairsData.jsonÂ src \u0026gt; functions \u0026gt; repairs.ts\nDonâ€™t worry about the files we just deleted. Weâ€™re going to create the essential files needed for ourÂ Breaking Bad AgentÂ from scratch. Up next, weâ€™ll fetch real-time data directly from the API and configure the agent to use it.\nStep 2: Create a New Function File for the Breaking Bad API Integration Next, we need to create a new file where our agent will interact with theÂ Breaking Bad API.Â Navigate to:Â src \u0026gt; functions Create a New File:Â Name itÂ quotes.ts Now, copy and paste the following code intoÂ quotes.ts. This function will act as anÂ Azure FunctionÂ responsible for sending requests and receiving quotes from the live Breaking Bad API.\nimportÂ {Â app,Â HttpResponseInitÂ }Â fromÂ \u0026#34;@azure/functions\u0026#34;;Â exportÂ asyncÂ functionÂ quotes():Â Promise\u0026lt;HttpResponseInit\u0026gt; {Â constÂ breakingbadResponseÂ =Â awaitÂ fetch(\u0026#39;https://api.breakingbadquotes.xyz/v1/quotes\u0026#39;);Â constÂ breakingbadDataÂ =Â awaitÂ breakingbadResponse.json();Â returnÂ {Â status:Â 200,Â jsonBody:Â {Â quotes:Â breakingbadData,Â },Â };Â }Â app.http(\u0026#34;quotes\u0026#34;, {Â methods:Â [\u0026#34;GET\u0026#34;],Â authLevel:Â \u0026#34;anonymous\u0026#34;,Â handler:Â quotes,Â }); If you encounter the error Cannot find module '@azure/functions' or its corresponding type, donâ€™t worry! This is a common issue, and the required modules will be automatically installed when you run the agent for the first time.\nStep 3: Create the API Specification File Now, let\u0026rsquo;s create the API specification file that will define how the declarative agent interacts with theÂ Breaking Bad API.\nNavigate to:Â appPackage \u0026gt; apiSpecificationfile Create a New File:Â Name itÂ quotes.yml openapi:Â 3.0.0Â info:Â title:Â Breaking bad Quote APIÂ description:Â Random Quote api from the Breaking Bad TV series with authorÂ version:Â 1.0.0Â servers:Â -Â url:Â ${{OPENAPI_SERVER_URL}}/apiÂ description:Â The quotes api serverÂ paths:Â /quotes:Â get:Â operationId:Â getQuotesÂ summary:Â get all breaking bad quotes with authorÂ description:Â Returns a single random quote from the Breaking Bad TV series with authorÂ responses:Â \u0026#39;200\u0026#39;:Â description:Â A random quote from the Breaking Bad TV series with authorÂ content:Â application/json:Â schema:Â type:Â objectÂ properties:Â results:Â type:Â arrayÂ items:Â type:Â objectÂ properties:Â quote:Â type:Â stringÂ description:Â Breaking bad quote with authorÂ author:Â type:Â stringÂ description:Â The author name of the quote Step 4: Update theÂ ai-plugin.jsonÂ File Now, let\u0026rsquo;s update the ai-plugin.json file so that the declarative agent is properly linked with the Breaking Bad API and the Azure Function.Â Navigate to:Â appPackage.Â Open the File: OpenÂ ai-plugin.json Remove:Â The \u0026quot;Static_template\u0026quot; entry Update:Â The runtimes URL and the function name as shown below: {Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json)\u0026#34;,Â \u0026#34;schema_version\u0026#34;:Â \u0026#34;v2.2\u0026#34;,Â \u0026#34;namespace\u0026#34;:Â \u0026#34;Breakingbadquotes\u0026#34;,Â \u0026#34;name_for_human\u0026#34;:Â \u0026#34;Breakingbadquotes Plugin\u0026#34;,Â \u0026#34;description_for_human\u0026#34;:Â \u0026#34;Generate random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;description_for_model\u0026#34;:Â \u0026#34;Plugin for generating random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;functions\u0026#34;: [Â {Â \u0026#34;name\u0026#34;:Â \u0026#34;getQuotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;Returns a random quote with author from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;response_semantics\u0026#34;: {Â \u0026#34;data_path\u0026#34;:Â \u0026#34;$.quotes\u0026#34;,Â \u0026#34;properties\u0026#34;: {Â \u0026#34;title\u0026#34;:Â \u0026#34;$.quote\u0026#34;,Â \u0026#34;subtitle\u0026#34;:Â \u0026#34;$.author\u0026#34;Â }Â }Â }Â } ],Â \u0026#34;runtimes\u0026#34;: [Â {Â \u0026#34;type\u0026#34;:Â \u0026#34;OpenApi\u0026#34;,Â \u0026#34;auth\u0026#34;: {Â \u0026#34;type\u0026#34;:Â \u0026#34;None\u0026#34;Â },Â \u0026#34;spec\u0026#34;: {Â \u0026#34;url\u0026#34;:Â \u0026#34;apiSpecificationFile/quotes.yml\u0026#34;,Â \u0026#34;progress_style\u0026#34;:Â \u0026#34;ShowUsageWithInputAndOutput\u0026#34;Â },Â \u0026#34;run_for_functions\u0026#34;: [\u0026#34;getQuotes\u0026#34;]Â }Â ],Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;conversation_starters\u0026#34;: []Â }Â } Step 5: Update the manifest.json File The manifest.json file serves as the app manifest for your declarative agent. It is specifying the agentâ€™s identity and the declarative agent configuration files. We\u0026rsquo;ll update it to reflect the Breaking Bad agent setup.\nNavigate to:Â appPackage Open the File:Â openÂ manifest.json Update:Â The \u0026quot;copilotAgents\u0026quot; section as shown below: You can also update the icon of your application in the same file. First, download any image and make sure it\u0026rsquo;s 192x192 pixels. Replace the existing icon with your new image by saving it as color.png in your project folder. If you choose to change the name of the image, make sure to update it in the application manifest.json file.\n{Â \u0026#34;copilotAgents\u0026#34;: {Â \u0026#34;declarativeAgents\u0026#34;: [Â {Â \u0026#34;id\u0026#34;: \u0026#34;breakingBadDeclarativeAgent\u0026#34;,Â \u0026#34;file\u0026#34;: \u0026#34;breakingBadDeclarativeAgent.json\u0026#34;Â }Â ]Â }Â } Step 6: Create the quotesDeclarativeAgent.json File We need to create theÂ agent manifest fileÂ which defines how the declarative agent behaves and interacts with the Breaking Bad API.\nNavigate to:Â appPackage Create a New File:Â Name itÂ quotesDeclarativeAgent.json Add the Following Content:\n{Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json)\u0026#34;,Â \u0026#34;version\u0026#34;:Â \u0026#34;v1.2\u0026#34;,Â \u0026#34;name\u0026#34;:Â \u0026#34;Breaking badquotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;This declarative agent helps you get a random quote from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;instructions\u0026#34;:Â \u0026#34;$[file(\u0026#39;instruction.txt\u0026#39;)]\u0026#34;,Â \u0026#34;conversation_starters\u0026#34;: [Â {Â \u0026#34;text\u0026#34;:Â \u0026#34;Give me a random quote from Breaking Bad with author name?\u0026#34;Â } ],Â \u0026#34;actions\u0026#34;: [Â {Â \u0026#34;id\u0026#34;:Â \u0026#34;quoteplugin\u0026#34;,Â \u0026#34;file\u0026#34;:Â \u0026#34;ai-plugin.json\u0026#34;Â }Â ]Â } Step 7: Update the instructions.txt File The instructions.txt file plays a crucial role in declarative agent setup. It defines how the agent should behave, respond to user queries, and interact with the Breaking Bad API. This make sures that the agent stays focused on its purpose and maintains a consistent user experience.\nUpdate it with the Following Content:\nYou are an assistant specialized in retrieving quotes from the provided API, ensuring a smooth and delightful user experience. Your responses should include the quote and its author.Â Guidelines:Â - Exclusive API Use: Do not perform web searches; rely solely on the provided API for data retrieval. Do not proceess any other request. This is solely for breaking bad quotes nothing else, keep in mind!Â - Response Format: Present the quote followed by the author\u0026#39;s name.Â - Error Handling: If the API does not return a quote, respond with: \u0026#34;I\u0026#39;m sorry, I couldn\u0026#39;t retrieve a quote at this moment.\u0026#34;Â - User Interaction: Maintain a friendly and engaging tone to ensure a delightful user experience. Showcase: The Final Outcome of All Efforts To run and debug your declarative agent, click on theÂ Run and DebugÂ icon inÂ VS Code, which can be found on the left sidebar. The process will take approximatelyÂ ~10-15 minutesÂ to initialize. During this time, a sign-in prompt will appear where youâ€™ll need to log in with yourÂ Microsoft 365 accountÂ credentials.\nOnce signed in, if you are not automatically redirected, you can manually visitÂ office.com/chat?auth=2Â to access the Copilot interface.\nSelect the prompt we defined earlier, and it will prompt you to process the query. Click on Always Allow to proceed.\nFinal Output:\nHow to Verify if It\u0026rsquo;s Working and Fetching Data from the API\nVerify via Localhost: Open the terminal in VS Code and click on Start Backend. Once it\u0026rsquo;s running, you\u0026rsquo;ll see the local host URL, which should begin with localhost:7071/api/quotes. Open this URL in your browser, and it will return a JSON response with the quote data. Verify via Agent Request: Another way to check is by sending a request from the agent. This will invoke the getQuote function, which generates a unique ID each time. The response will include text indicating that the function was programmatically called. Bonus: How does the breaking bad quotes agent work? When a user requests a Breaking Bad quote in Microsoft 365 Copilot, the agent works in a few simple steps:Â Manifest Check:Â The agent starts by checking its task list in theÂ manifest file API Connection:Â It then refers to theÂ API specificationÂ to understand how to connect to the Breaking Bad API Data Fetch:Â The agent sends a request to anÂ Azure Function, which fetches a random quote and the authorâ€™s name from the API Data Return:Â The quote and author are returned in a structured JSON format User Display:Â Finally, the agent displays the quote clearly in the Copilot interface Conclusion Itâ€™s been a bit of a ride, hasnâ€™t it? But hey, weâ€™ve finally done it! We have successfully created a declarative agent using the Breaking Bad API, but the process can be applied to any API, including those requiring authentication with API key or OAuth.\nif you hit any bumps along the way, donâ€™t hesitate to drop a comment below. If you found this helpful, give it a thumbs up or click on your favorite emoji button below. Good luck, and happy coding!\nAppendix\nThis post is inspired by the following resources:\nIntroducing New Agents in Microsoft 365 Extending Copilot for Microsoft 365 Workshop on Building Declarative Agents for Microsoft 365 Copilot Breaking Bad Quotes API Breaking Bad Icon by Icons8 ","permalink":"http://localhost:1313/blog/2025/january/create-a-custom-declarative-agent-with-breaking-bad-api/","summary":"\u003cp\u003eBack inÂ November 2024, Microsoft introduced newÂ \u003ca href=\"https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918?utm_source=chatgpt.com\"\u003eAI-powered agents\u003c/a\u003eÂ in Microsoft 365 Copilot.Â Â \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/overview-declarative-agent\"\u003eDeclarative agents\u003c/a\u003eÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â \u003c/p\u003e","title":"Create a Custom Declarative Agent with Breaking Bad API"},{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below example shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"},{"content":"Back inÂ November 2024, Microsoft introduced newÂ AI-powered agentsÂ in Microsoft 365 Copilot.Â Declarative agentsÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â Today, we will create a custom declarative agent using an open-source API to demonstrate how agents can interact with external data sources.\nOpen Source API Overview:\nWe\u0026rsquo;ll be using theÂ Breaking Bad API, an open-source API that provides quotes from the popular TV seriesÂ Breaking Bad. The API response will return a quote along with the author\u0026rsquo;s name (character name) from the series.\nSample Response from API\nLetâ€™s get started!\nStep 1: Creating a Custom Declarative Agent Using Microsoft Toolkit Extension Let\u0026rsquo;s begin by creating a custom declarative agent using the Microsoft Toolkit extension. Follow these step-by-step instructions to set up your agent:Â Launch the Microsoft Toolkit Extension and click on Create a New App under Create a Project or Explore Samples Choose Agent as your app type Select Declarative Agent to build an agent powered by Microsoft 365 Copilot Click Add Plugin to connect external APIs to your agent Choose Start with a New API to set up a fresh connection for your agent Pick None for authentication since the Breaking Bad API doesnâ€™t require it Opt for TypeScript as programming language for a smoother experience Select a folder to store project files (pro tip: avoid saving it in the C drive for better organization) Finally, give your agent a name like BreakingBad Agent and hit the setup button Wohooo!Â ðŸŽ‰Â You\u0026rsquo;ve Successfully Created Your Declarative Agent with an API Plugin! After completing the setup, a new window will pop up inÂ VS CodeÂ with your project structure ready. But waitâ€”there\u0026rsquo;s more!Â By default, the project folder includes a demo API plugin. However, this plugin uses a local json file as its data source. Since we want to fetch real-time data from an actual API, we will need to remove the existing demo setup.\nClean Up the Default Files\nNow that your declarative agent is set up, it\u0026rsquo;s time to remove the default files that use local data. Since we will be working with a live API instead, delete the following files from your project directory:Â appPackage \u0026gt; apiSpecificationfile \u0026gt; repair.ymlÂ appPackage \u0026gt; repairDeclarativeAgent.jsonÂ src \u0026gt; RepairsData.jsonÂ src \u0026gt; functions \u0026gt; repairs.ts\nDonâ€™t worry about the files we just deleted. Weâ€™re going to create the essential files needed for ourÂ Breaking Bad AgentÂ from scratch. Up next, weâ€™ll fetch real-time data directly from the API and configure the agent to use it.\nStep 2: Create a New Function File for the Breaking Bad API Integration Next, we need to create a new file where our agent will interact with theÂ Breaking Bad API.Â Navigate to:Â src \u0026gt; functions Create a New File:Â Name itÂ quotes.ts Now, copy and paste the following code intoÂ quotes.ts. This function will act as anÂ Azure FunctionÂ responsible for sending requests and receiving quotes from the live Breaking Bad API.\nimportÂ {Â app,Â HttpResponseInitÂ }Â fromÂ \u0026#34;@azure/functions\u0026#34;;Â exportÂ asyncÂ functionÂ quotes():Â Promise\u0026lt;HttpResponseInit\u0026gt; {Â constÂ breakingbadResponseÂ =Â awaitÂ fetch(\u0026#39;https://api.breakingbadquotes.xyz/v1/quotes\u0026#39;);Â constÂ breakingbadDataÂ =Â awaitÂ breakingbadResponse.json();Â returnÂ {Â status:Â 200,Â jsonBody:Â {Â quotes:Â breakingbadData,Â },Â };Â }Â app.http(\u0026#34;quotes\u0026#34;, {Â methods:Â [\u0026#34;GET\u0026#34;],Â authLevel:Â \u0026#34;anonymous\u0026#34;,Â handler:Â quotes,Â }); If you encounter the error Cannot find module '@azure/functions' or its corresponding type, donâ€™t worry! This is a common issue, and the required modules will be automatically installed when you run the agent for the first time.\nStep 3: Create the API Specification File Now, let\u0026rsquo;s create the API specification file that will define how the declarative agent interacts with theÂ Breaking Bad API.\nNavigate to:Â appPackage \u0026gt; apiSpecificationfile Create a New File:Â Name itÂ quotes.yml openapi:Â 3.0.0Â info:Â title:Â Breaking bad Quote APIÂ description:Â Random Quote api from the Breaking Bad TV series with authorÂ version:Â 1.0.0Â servers:Â -Â url:Â ${{OPENAPI_SERVER_URL}}/apiÂ description:Â The quotes api serverÂ paths:Â /quotes:Â get:Â operationId:Â getQuotesÂ summary:Â get all breaking bad quotes with authorÂ description:Â Returns a single random quote from the Breaking Bad TV series with authorÂ responses:Â \u0026#39;200\u0026#39;:Â description:Â A random quote from the Breaking Bad TV series with authorÂ content:Â application/json:Â schema:Â type:Â objectÂ properties:Â results:Â type:Â arrayÂ items:Â type:Â objectÂ properties:Â quote:Â type:Â stringÂ description:Â Breaking bad quote with authorÂ author:Â type:Â stringÂ description:Â The author name of the quote Step 4: Update theÂ ai-plugin.jsonÂ File Now, let\u0026rsquo;s update the ai-plugin.json file so that the declarative agent is properly linked with the Breaking Bad API and the Azure Function.Â Navigate to:Â appPackage.Â Open the File: OpenÂ ai-plugin.json Remove:Â The \u0026quot;Static_template\u0026quot; entry Update:Â The runtimes URL and the function name as shown below: {Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json)\u0026#34;,Â \u0026#34;schema_version\u0026#34;:Â \u0026#34;v2.2\u0026#34;,Â \u0026#34;namespace\u0026#34;:Â \u0026#34;Breakingbadquotes\u0026#34;,Â \u0026#34;name_for_human\u0026#34;:Â \u0026#34;Breakingbadquotes Plugin\u0026#34;,Â \u0026#34;description_for_human\u0026#34;:Â \u0026#34;Generate random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;description_for_model\u0026#34;:Â \u0026#34;Plugin for generating random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;functions\u0026#34;: [Â {Â \u0026#34;name\u0026#34;:Â \u0026#34;getQuotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;Returns a random quote with author from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;response_semantics\u0026#34;: {Â \u0026#34;data_path\u0026#34;:Â \u0026#34;$.quotes\u0026#34;,Â \u0026#34;properties\u0026#34;: {Â \u0026#34;title\u0026#34;:Â \u0026#34;$.quote\u0026#34;,Â \u0026#34;subtitle\u0026#34;:Â \u0026#34;$.author\u0026#34;Â }Â }Â }Â } ],Â \u0026#34;runtimes\u0026#34;: [Â {Â \u0026#34;type\u0026#34;:Â \u0026#34;OpenApi\u0026#34;,Â \u0026#34;auth\u0026#34;: {Â \u0026#34;type\u0026#34;:Â \u0026#34;None\u0026#34;Â },Â \u0026#34;spec\u0026#34;: {Â \u0026#34;url\u0026#34;:Â \u0026#34;apiSpecificationFile/quotes.yml\u0026#34;,Â \u0026#34;progress_style\u0026#34;:Â \u0026#34;ShowUsageWithInputAndOutput\u0026#34;Â },Â \u0026#34;run_for_functions\u0026#34;: [\u0026#34;getQuotes\u0026#34;]Â }Â ],Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;conversation_starters\u0026#34;: []Â }Â } Step 5: Update the manifest.json File The manifest.json file serves as the app manifest for your declarative agent. It is specifying the agentâ€™s identity and the declarative agent configuration files. We\u0026rsquo;ll update it to reflect the Breaking Bad agent setup.\nNavigate to:Â appPackage Open the File:Â openÂ manifest.json Update:Â The \u0026quot;copilotAgents\u0026quot; section as shown below: You can also update the icon of your application in the same file. First, download any image and make sure it\u0026rsquo;s 192x192 pixels. Replace the existing icon with your new image by saving it as color.png in your project folder. If you choose to change the name of the image, make sure to update it in the application manifest.json file.\n{Â \u0026#34;copilotAgents\u0026#34;: {Â \u0026#34;declarativeAgents\u0026#34;: [Â {Â \u0026#34;id\u0026#34;: \u0026#34;breakingBadDeclarativeAgent\u0026#34;,Â \u0026#34;file\u0026#34;: \u0026#34;breakingBadDeclarativeAgent.json\u0026#34;Â }Â ]Â }Â } Step 6: Create the quotesDeclarativeAgent.json File We need to create theÂ agent manifest fileÂ which defines how the declarative agent behaves and interacts with the Breaking Bad API.\nNavigate to:Â appPackage Create a New File:Â Name itÂ quotesDeclarativeAgent.json Add the Following Content:\n{Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json)\u0026#34;,Â \u0026#34;version\u0026#34;:Â \u0026#34;v1.2\u0026#34;,Â \u0026#34;name\u0026#34;:Â \u0026#34;Breaking badquotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;This declarative agent helps you get a random quote from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;instructions\u0026#34;:Â \u0026#34;$[file(\u0026#39;instruction.txt\u0026#39;)]\u0026#34;,Â \u0026#34;conversation_starters\u0026#34;: [Â {Â \u0026#34;text\u0026#34;:Â \u0026#34;Give me a random quote from Breaking Bad with author name?\u0026#34;Â } ],Â \u0026#34;actions\u0026#34;: [Â {Â \u0026#34;id\u0026#34;:Â \u0026#34;quoteplugin\u0026#34;,Â \u0026#34;file\u0026#34;:Â \u0026#34;ai-plugin.json\u0026#34;Â }Â ]Â } Step 7: Update the instructions.txt File The instructions.txt file plays a crucial role in declarative agent setup. It defines how the agent should behave, respond to user queries, and interact with the Breaking Bad API. This make sures that the agent stays focused on its purpose and maintains a consistent user experience.\nUpdate it with the Following Content:\nYou are an assistant specialized in retrieving quotes from the provided API, ensuring a smooth and delightful user experience. Your responses should include the quote and its author.Â Guidelines:Â - Exclusive API Use: Do not perform web searches; rely solely on the provided API for data retrieval. Do not proceess any other request. This is solely for breaking bad quotes nothing else, keep in mind!Â - Response Format: Present the quote followed by the author\u0026#39;s name.Â - Error Handling: If the API does not return a quote, respond with: \u0026#34;I\u0026#39;m sorry, I couldn\u0026#39;t retrieve a quote at this moment.\u0026#34;Â - User Interaction: Maintain a friendly and engaging tone to ensure a delightful user experience. Showcase: The Final Outcome of All Efforts To run and debug your declarative agent, click on theÂ Run and DebugÂ icon inÂ VS Code, which can be found on the left sidebar. The process will take approximatelyÂ ~10-15 minutesÂ to initialize. During this time, a sign-in prompt will appear where youâ€™ll need to log in with yourÂ Microsoft 365 accountÂ credentials.\nOnce signed in, if you are not automatically redirected, you can manually visitÂ office.com/chat?auth=2Â to access the Copilot interface.\nSelect the prompt we defined earlier, and it will prompt you to process the query. Click on Always Allow to proceed.\nFinal Output:\nHow to Verify if It\u0026rsquo;s Working and Fetching Data from the API\nVerify via Localhost: Open the terminal in VS Code and click on Start Backend. Once it\u0026rsquo;s running, you\u0026rsquo;ll see the local host URL, which should begin with localhost:7071/api/quotes. Open this URL in your browser, and it will return a JSON response with the quote data. Verify via Agent Request: Another way to check is by sending a request from the agent. This will invoke the getQuote function, which generates a unique ID each time. The response will include text indicating that the function was programmatically called. Bonus: How does the breaking bad quotes agent work? When a user requests a Breaking Bad quote in Microsoft 365 Copilot, the agent works in a few simple steps:Â Manifest Check:Â The agent starts by checking its task list in theÂ manifest file API Connection:Â It then refers to theÂ API specificationÂ to understand how to connect to the Breaking Bad API Data Fetch:Â The agent sends a request to anÂ Azure Function, which fetches a random quote and the authorâ€™s name from the API Data Return:Â The quote and author are returned in a structured JSON format User Display:Â Finally, the agent displays the quote clearly in the Copilot interface Conclusion Itâ€™s been a bit of a ride, hasnâ€™t it? But hey, weâ€™ve finally done it! We have successfully created a declarative agent using the Breaking Bad API, but the process can be applied to any API, including those requiring authentication with API key or OAuth.\nif you hit any bumps along the way, donâ€™t hesitate to drop a comment below. If you found this helpful, give it a thumbs up or click on your favorite emoji button below. Good luck, and happy coding!\nAppendix\nThis post is inspired by the following resources:\nIntroducing New Agents in Microsoft 365 Extending Copilot for Microsoft 365 Workshop on Building Declarative Agents for Microsoft 365 Copilot Breaking Bad Quotes API Breaking Bad Icon by Icons8 ","permalink":"http://localhost:1313/blog/2025/january/create-a-custom-declarative-agent-with-breaking-bad-api/","summary":"\u003cp\u003eBack inÂ November 2024, Microsoft introduced newÂ \u003ca href=\"https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918?utm_source=chatgpt.com\"\u003eAI-powered agents\u003c/a\u003eÂ in Microsoft 365 Copilot.Â Â \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/overview-declarative-agent\"\u003eDeclarative agents\u003c/a\u003eÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â \u003c/p\u003e","title":"Create a Custom Declarative Agent with Breaking Bad API"},{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below example shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"},{"content":"Back inÂ November 2024, Microsoft introduced newÂ AI-powered agentsÂ in Microsoft 365 Copilot.Â Declarative agentsÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â Today, we will create a custom declarative agent using an open-source API to demonstrate how agents can interact with external data sources.\nOpen Source API Overview:\nWe\u0026rsquo;ll be using theÂ Breaking Bad API, an open-source API that provides quotes from the popular TV seriesÂ Breaking Bad. The API response will return a quote along with the author\u0026rsquo;s name (character name) from the series.\nSample Response from API ðŸ‘‡\nLetâ€™s get started!\nStep 1: Creating a Custom Declarative Agent Using Microsoft Toolkit Extension Let\u0026rsquo;s begin by creating a custom declarative agent using the Microsoft Toolkit extension. Follow these step-by-step instructions to set up your agent:Â Launch the Microsoft Toolkit Extension and click on Create a New App under Create a Project or Explore Samples Choose Agent as your app type Select Declarative Agent to build an agent powered by Microsoft 365 Copilot Click Add Plugin to connect external APIs to your agent Choose Start with a New API to set up a fresh connection for your agent Pick None for authentication since the Breaking Bad API doesnâ€™t require it Opt for TypeScript as programming language for a smoother experience Select a folder to store project files (pro tip: avoid saving it in the C drive for better organization) Finally, give your agent a name like BreakingBad Agent and hit the setup button Wohooo!Â ðŸŽ‰Â You\u0026rsquo;ve Successfully Created Your Declarative Agent with an API Plugin! After completing the setup, a new window will pop up inÂ VS CodeÂ with your project structure ready. But waitâ€”there\u0026rsquo;s more!Â By default, the project folder includes a demo API plugin. However, this plugin uses a local json file as its data source. Since we want to fetch real-time data from an actual API, we will need to remove the existing demo setup.\nClean Up the Default Files\nNow that your declarative agent is set up, it\u0026rsquo;s time to remove the default files that use local data. Since we will be working with a live API instead, delete the following files from your project directory:Â appPackage \u0026gt; apiSpecificationfile \u0026gt; repair.ymlÂ appPackage \u0026gt; repairDeclarativeAgent.jsonÂ src \u0026gt; RepairsData.jsonÂ src \u0026gt; functions \u0026gt; repairs.ts\nDonâ€™t worry about the files we just deleted. Weâ€™re going to create the essential files needed for ourÂ Breaking Bad AgentÂ from scratch. Up next, weâ€™ll fetch real-time data directly from the API and configure the agent to use it.\nStep 2: Create a New Function File for the Breaking Bad API Integration Next, we need to create a new file where our agent will interact with theÂ Breaking Bad API.Â Navigate to:Â src \u0026gt; functions Create a New File:Â Name itÂ quotes.ts Now, copy and paste the following code intoÂ quotes.ts. This function will act as anÂ Azure FunctionÂ responsible for sending requests and receiving quotes from the live Breaking Bad API.\nimportÂ {Â app,Â HttpResponseInitÂ }Â fromÂ \u0026#34;@azure/functions\u0026#34;;Â exportÂ asyncÂ functionÂ quotes():Â Promise\u0026lt;HttpResponseInit\u0026gt; {Â constÂ breakingbadResponseÂ =Â awaitÂ fetch(\u0026#39;https://api.breakingbadquotes.xyz/v1/quotes\u0026#39;);Â constÂ breakingbadDataÂ =Â awaitÂ breakingbadResponse.json();Â returnÂ {Â status:Â 200,Â jsonBody:Â {Â quotes:Â breakingbadData,Â },Â };Â }Â app.http(\u0026#34;quotes\u0026#34;, {Â methods:Â [\u0026#34;GET\u0026#34;],Â authLevel:Â \u0026#34;anonymous\u0026#34;,Â handler:Â quotes,Â }); If you encounter the error Cannot find module '@azure/functions' or its corresponding type, donâ€™t worry! This is a common issue, and the required modules will be automatically installed when you run the agent for the first time.\nStep 3: Create the API Specification File Now, let\u0026rsquo;s create the API specification file that will define how the declarative agent interacts with theÂ Breaking Bad API.\nNavigate to:Â appPackage \u0026gt; apiSpecificationfile Create a New File:Â Name itÂ quotes.yml openapi:Â 3.0.0Â info:Â title:Â Breaking bad Quote APIÂ description:Â Random Quote api from the Breaking Bad TV series with authorÂ version:Â 1.0.0Â servers:Â -Â url:Â ${{OPENAPI_SERVER_URL}}/apiÂ description:Â The quotes api serverÂ paths:Â /quotes:Â get:Â operationId:Â getQuotesÂ summary:Â get all breaking bad quotes with authorÂ description:Â Returns a single random quote from the Breaking Bad TV series with authorÂ responses:Â \u0026#39;200\u0026#39;:Â description:Â A random quote from the Breaking Bad TV series with authorÂ content:Â application/json:Â schema:Â type:Â objectÂ properties:Â results:Â type:Â arrayÂ items:Â type:Â objectÂ properties:Â quote:Â type:Â stringÂ description:Â Breaking bad quote with authorÂ author:Â type:Â stringÂ description:Â The author name of the quote Step 4: Update theÂ ai-plugin.jsonÂ File Now, let\u0026rsquo;s update the ai-plugin.json file so that the declarative agent is properly linked with the Breaking Bad API and the Azure Function.Â Navigate to:Â appPackage.Â Open the File: OpenÂ ai-plugin.json Remove:Â The \u0026quot;Static_template\u0026quot; entry Update:Â The runtimes URL and the function name as shown below: {Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json)\u0026#34;,Â \u0026#34;schema_version\u0026#34;:Â \u0026#34;v2.2\u0026#34;,Â \u0026#34;namespace\u0026#34;:Â \u0026#34;Breakingbadquotes\u0026#34;,Â \u0026#34;name_for_human\u0026#34;:Â \u0026#34;Breakingbadquotes Plugin\u0026#34;,Â \u0026#34;description_for_human\u0026#34;:Â \u0026#34;Generate random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;description_for_model\u0026#34;:Â \u0026#34;Plugin for generating random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;functions\u0026#34;: [Â {Â \u0026#34;name\u0026#34;:Â \u0026#34;getQuotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;Returns a random quote with author from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;response_semantics\u0026#34;: {Â \u0026#34;data_path\u0026#34;:Â \u0026#34;$.quotes\u0026#34;,Â \u0026#34;properties\u0026#34;: {Â \u0026#34;title\u0026#34;:Â \u0026#34;$.quote\u0026#34;,Â \u0026#34;subtitle\u0026#34;:Â \u0026#34;$.author\u0026#34;Â }Â }Â }Â } ],Â \u0026#34;runtimes\u0026#34;: [Â {Â \u0026#34;type\u0026#34;:Â \u0026#34;OpenApi\u0026#34;,Â \u0026#34;auth\u0026#34;: {Â \u0026#34;type\u0026#34;:Â \u0026#34;None\u0026#34;Â },Â \u0026#34;spec\u0026#34;: {Â \u0026#34;url\u0026#34;:Â \u0026#34;apiSpecificationFile/quotes.yml\u0026#34;,Â \u0026#34;progress_style\u0026#34;:Â \u0026#34;ShowUsageWithInputAndOutput\u0026#34;Â },Â \u0026#34;run_for_functions\u0026#34;: [\u0026#34;getQuotes\u0026#34;]Â }Â ],Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;conversation_starters\u0026#34;: []Â }Â } Step 5: Update the manifest.json File The manifest.json file serves as the app manifest for your declarative agent. It is specifying the agentâ€™s identity and the declarative agent configuration files. We\u0026rsquo;ll update it to reflect the Breaking Bad agent setup.\nNavigate to:Â appPackage Open the File:Â openÂ manifest.json Update:Â The \u0026quot;copilotAgents\u0026quot; section as shown below: You can also update the icon of your application in the same file. First, download any image and make sure it\u0026rsquo;s 192x192 pixels. Replace the existing icon with your new image by saving it as color.png in your project folder. If you choose to change the name of the image, make sure to update it in the application manifest.json file.\n{Â \u0026#34;copilotAgents\u0026#34;: {Â \u0026#34;declarativeAgents\u0026#34;: [Â {Â \u0026#34;id\u0026#34;: \u0026#34;breakingBadDeclarativeAgent\u0026#34;,Â \u0026#34;file\u0026#34;: \u0026#34;breakingBadDeclarativeAgent.json\u0026#34;Â }Â ]Â }Â } Step 6: Create the quotesDeclarativeAgent.json File We need to create theÂ agent manifest fileÂ which defines how the declarative agent behaves and interacts with the Breaking Bad API.\nNavigate to:Â appPackage Create a New File:Â Name itÂ quotesDeclarativeAgent.json Add the Following Content:\n{Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json)\u0026#34;,Â \u0026#34;version\u0026#34;:Â \u0026#34;v1.2\u0026#34;,Â \u0026#34;name\u0026#34;:Â \u0026#34;Breaking badquotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;This declarative agent helps you get a random quote from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;instructions\u0026#34;:Â \u0026#34;$[file(\u0026#39;instruction.txt\u0026#39;)]\u0026#34;,Â \u0026#34;conversation_starters\u0026#34;: [Â {Â \u0026#34;text\u0026#34;:Â \u0026#34;Give me a random quote from Breaking Bad with author name?\u0026#34;Â } ],Â \u0026#34;actions\u0026#34;: [Â {Â \u0026#34;id\u0026#34;:Â \u0026#34;quoteplugin\u0026#34;,Â \u0026#34;file\u0026#34;:Â \u0026#34;ai-plugin.json\u0026#34;Â }Â ]Â } Step 7: Update the instructions.txt File The instructions.txt file plays a crucial role in declarative agent setup. It defines how the agent should behave, respond to user queries, and interact with the Breaking Bad API. This make sures that the agent stays focused on its purpose and maintains a consistent user experience.\nUpdate it with the Following Content:\nYou are an assistant specialized in retrieving quotes from the provided API, ensuring a smooth and delightful user experience. Your responses should include the quote and its author.Â Guidelines:Â - Exclusive API Use: Do not perform web searches; rely solely on the provided API for data retrieval. Do not proceess any other request. This is solely for breaking bad quotes nothing else, keep in mind!Â - Response Format: Present the quote followed by the author\u0026#39;s name.Â - Error Handling: If the API does not return a quote, respond with: \u0026#34;I\u0026#39;m sorry, I couldn\u0026#39;t retrieve a quote at this moment.\u0026#34;Â - User Interaction: Maintain a friendly and engaging tone to ensure a delightful user experience. Showcase: The Final Outcome of All Efforts To run and debug your declarative agent, click on theÂ Run and DebugÂ icon inÂ VS Code, which can be found on the left sidebar. The process will take approximatelyÂ ~10-15 minutesÂ to initialize. During this time, a sign-in prompt will appear where youâ€™ll need to log in with yourÂ Microsoft 365 accountÂ credentials.\nOnce signed in, if you are not automatically redirected, you can manually visitÂ office.com/chat?auth=2Â to access the Copilot interface.\nSelect the prompt we defined earlier, and it will prompt you to process the query. Click on Always Allow to proceed.\nFinal Output:\nHow to Verify if It\u0026rsquo;s Working and Fetching Data from the API\nVerify via Localhost: Open the terminal in VS Code and click on Start Backend. Once it\u0026rsquo;s running, you\u0026rsquo;ll see the local host URL, which should begin with localhost:7071/api/quotes. Open this URL in your browser, and it will return a JSON response with the quote data. Verify via Agent Request: Another way to check is by sending a request from the agent. This will invoke the getQuote function, which generates a unique ID each time. The response will include text indicating that the function was programmatically called. Bonus: How does the breaking bad quotes agent work? When a user requests a Breaking Bad quote in Microsoft 365 Copilot, the agent works in a few simple steps:Â Manifest Check:Â The agent starts by checking its task list in theÂ manifest file API Connection:Â It then refers to theÂ API specificationÂ to understand how to connect to the Breaking Bad API Data Fetch:Â The agent sends a request to anÂ Azure Function, which fetches a random quote and the authorâ€™s name from the API Data Return:Â The quote and author are returned in a structured JSON format User Display:Â Finally, the agent displays the quote clearly in the Copilot interface Conclusion Itâ€™s been a bit of a ride, hasnâ€™t it? But hey, weâ€™ve finally done it! We have successfully created a declarative agent using the Breaking Bad API, but the process can be applied to any API, including those requiring authentication with API key or OAuth.\nif you hit any bumps along the way, donâ€™t hesitate to drop a comment below. If you found this helpful, give it a thumbs up or click on your favorite emoji button below. Good luck, and happy coding!\nAppendix\nThis post is inspired by the following resources:\nIntroducing New Agents in Microsoft 365 Extending Copilot for Microsoft 365 Workshop on Building Declarative Agents for Microsoft 365 Copilot Breaking Bad Quotes API Breaking Bad Icon by Icons8 ","permalink":"http://localhost:1313/blog/2025/january/create-a-custom-declarative-agent-with-breaking-bad-api/","summary":"\u003cp\u003eBack inÂ November 2024, Microsoft introduced newÂ \u003ca href=\"https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918?utm_source=chatgpt.com\"\u003eAI-powered agents\u003c/a\u003eÂ in Microsoft 365 Copilot.Â Â \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/overview-declarative-agent\"\u003eDeclarative agents\u003c/a\u003eÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â \u003c/p\u003e","title":"Create a Custom Declarative Agent with Breaking Bad API"},{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below example shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"},{"content":"Back inÂ November 2024, Microsoft introduced newÂ AI-powered agentsÂ in Microsoft 365 Copilot.Â Declarative agentsÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â Today, we will create a custom declarative agent using an open-source API to demonstrate how agents can interact with external data sources.\nOpen Source API Overview:\nWe\u0026rsquo;ll be using theÂ Breaking Bad API, an open-source API that provides quotes from the popular TV seriesÂ Breaking Bad. The API response will return a quote along with the author\u0026rsquo;s name (character name) from the series.\nðŸ‘‡ Sample Response from API ðŸ‘‡\nLetâ€™s get started!\nStep 1: Creating a Custom Declarative Agent Using Microsoft Toolkit Extension Let\u0026rsquo;s begin by creating a custom declarative agent using the Microsoft Toolkit extension. Follow these step-by-step instructions to set up your agent:Â Launch the Microsoft Toolkit Extension and click on Create a New App under Create a Project or Explore Samples Choose Agent as your app type Select Declarative Agent to build an agent powered by Microsoft 365 Copilot Click Add Plugin to connect external APIs to your agent Choose Start with a New API to set up a fresh connection for your agent Pick None for authentication since the Breaking Bad API doesnâ€™t require it Opt for TypeScript as programming language for a smoother experience Select a folder to store project files (pro tip: avoid saving it in the C drive for better organization) Finally, give your agent a name like BreakingBad Agent and hit the setup button Wohooo!Â ðŸŽ‰Â You\u0026rsquo;ve Successfully Created Your Declarative Agent with an API Plugin! After completing the setup, a new window will pop up inÂ VS CodeÂ with your project structure ready. But waitâ€”there\u0026rsquo;s more!Â By default, the project folder includes a demo API plugin. However, this plugin uses a local json file as its data source. Since we want to fetch real-time data from an actual API, we will need to remove the existing demo setup.\nClean Up the Default Files\nNow that your declarative agent is set up, it\u0026rsquo;s time to remove the default files that use local data. Since we will be working with a live API instead, delete the following files from your project directory:Â appPackage \u0026gt; apiSpecificationfile \u0026gt; repair.ymlÂ appPackage \u0026gt; repairDeclarativeAgent.jsonÂ src \u0026gt; RepairsData.jsonÂ src \u0026gt; functions \u0026gt; repairs.ts\nDonâ€™t worry about the files we just deleted. Weâ€™re going to create the essential files needed for ourÂ Breaking Bad AgentÂ from scratch. Up next, weâ€™ll fetch real-time data directly from the API and configure the agent to use it.\nStep 2: Create a New Function File for the Breaking Bad API Integration Next, we need to create a new file where our agent will interact with theÂ Breaking Bad API.Â Navigate to:Â src \u0026gt; functions Create a New File:Â Name itÂ quotes.ts Now, copy and paste the following code intoÂ quotes.ts. This function will act as anÂ Azure FunctionÂ responsible for sending requests and receiving quotes from the live Breaking Bad API.\nimportÂ {Â app,Â HttpResponseInitÂ }Â fromÂ \u0026#34;@azure/functions\u0026#34;;Â exportÂ asyncÂ functionÂ quotes():Â Promise\u0026lt;HttpResponseInit\u0026gt; {Â constÂ breakingbadResponseÂ =Â awaitÂ fetch(\u0026#39;https://api.breakingbadquotes.xyz/v1/quotes\u0026#39;);Â constÂ breakingbadDataÂ =Â awaitÂ breakingbadResponse.json();Â returnÂ {Â status:Â 200,Â jsonBody:Â {Â quotes:Â breakingbadData,Â },Â };Â }Â app.http(\u0026#34;quotes\u0026#34;, {Â methods:Â [\u0026#34;GET\u0026#34;],Â authLevel:Â \u0026#34;anonymous\u0026#34;,Â handler:Â quotes,Â }); If you encounter the error Cannot find module '@azure/functions' or its corresponding type, donâ€™t worry! This is a common issue, and the required modules will be automatically installed when you run the agent for the first time.\nStep 3: Create the API Specification File Now, let\u0026rsquo;s create the API specification file that will define how the declarative agent interacts with theÂ Breaking Bad API.\nNavigate to:Â appPackage \u0026gt; apiSpecificationfile Create a New File:Â Name itÂ quotes.yml openapi:Â 3.0.0Â info:Â title:Â Breaking bad Quote APIÂ description:Â Random Quote api from the Breaking Bad TV series with authorÂ version:Â 1.0.0Â servers:Â -Â url:Â ${{OPENAPI_SERVER_URL}}/apiÂ description:Â The quotes api serverÂ paths:Â /quotes:Â get:Â operationId:Â getQuotesÂ summary:Â get all breaking bad quotes with authorÂ description:Â Returns a single random quote from the Breaking Bad TV series with authorÂ responses:Â \u0026#39;200\u0026#39;:Â description:Â A random quote from the Breaking Bad TV series with authorÂ content:Â application/json:Â schema:Â type:Â objectÂ properties:Â results:Â type:Â arrayÂ items:Â type:Â objectÂ properties:Â quote:Â type:Â stringÂ description:Â Breaking bad quote with authorÂ author:Â type:Â stringÂ description:Â The author name of the quote Step 4: Update theÂ ai-plugin.jsonÂ File Now, let\u0026rsquo;s update the ai-plugin.json file so that the declarative agent is properly linked with the Breaking Bad API and the Azure Function.Â Navigate to:Â appPackage.Â Open the File: OpenÂ ai-plugin.json Remove:Â The \u0026quot;Static_template\u0026quot; entry Update:Â The runtimes URL and the function name as shown below: {Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json)\u0026#34;,Â \u0026#34;schema_version\u0026#34;:Â \u0026#34;v2.2\u0026#34;,Â \u0026#34;namespace\u0026#34;:Â \u0026#34;Breakingbadquotes\u0026#34;,Â \u0026#34;name_for_human\u0026#34;:Â \u0026#34;Breakingbadquotes Plugin\u0026#34;,Â \u0026#34;description_for_human\u0026#34;:Â \u0026#34;Generate random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;description_for_model\u0026#34;:Â \u0026#34;Plugin for generating random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;functions\u0026#34;: [Â {Â \u0026#34;name\u0026#34;:Â \u0026#34;getQuotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;Returns a random quote with author from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;response_semantics\u0026#34;: {Â \u0026#34;data_path\u0026#34;:Â \u0026#34;$.quotes\u0026#34;,Â \u0026#34;properties\u0026#34;: {Â \u0026#34;title\u0026#34;:Â \u0026#34;$.quote\u0026#34;,Â \u0026#34;subtitle\u0026#34;:Â \u0026#34;$.author\u0026#34;Â }Â }Â }Â } ],Â \u0026#34;runtimes\u0026#34;: [Â {Â \u0026#34;type\u0026#34;:Â \u0026#34;OpenApi\u0026#34;,Â \u0026#34;auth\u0026#34;: {Â \u0026#34;type\u0026#34;:Â \u0026#34;None\u0026#34;Â },Â \u0026#34;spec\u0026#34;: {Â \u0026#34;url\u0026#34;:Â \u0026#34;apiSpecificationFile/quotes.yml\u0026#34;,Â \u0026#34;progress_style\u0026#34;:Â \u0026#34;ShowUsageWithInputAndOutput\u0026#34;Â },Â \u0026#34;run_for_functions\u0026#34;: [\u0026#34;getQuotes\u0026#34;]Â }Â ],Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;conversation_starters\u0026#34;: []Â }Â } Step 5: Update the manifest.json File The manifest.json file serves as the app manifest for your declarative agent. It is specifying the agentâ€™s identity and the declarative agent configuration files. We\u0026rsquo;ll update it to reflect the Breaking Bad agent setup.\nNavigate to:Â appPackage Open the File:Â openÂ manifest.json Update:Â The \u0026quot;copilotAgents\u0026quot; section as shown below: You can also update the icon of your application in the same file. First, download any image and make sure it\u0026rsquo;s 192x192 pixels. Replace the existing icon with your new image by saving it as color.png in your project folder. If you choose to change the name of the image, make sure to update it in the application manifest.json file.\n{Â \u0026#34;copilotAgents\u0026#34;: {Â \u0026#34;declarativeAgents\u0026#34;: [Â {Â \u0026#34;id\u0026#34;: \u0026#34;breakingBadDeclarativeAgent\u0026#34;,Â \u0026#34;file\u0026#34;: \u0026#34;breakingBadDeclarativeAgent.json\u0026#34;Â }Â ]Â }Â } Step 6: Create the quotesDeclarativeAgent.json File We need to create theÂ agent manifest fileÂ which defines how the declarative agent behaves and interacts with the Breaking Bad API.\nNavigate to:Â appPackage Create a New File:Â Name itÂ quotesDeclarativeAgent.json Add the Following Content:\n{Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json)\u0026#34;,Â \u0026#34;version\u0026#34;:Â \u0026#34;v1.2\u0026#34;,Â \u0026#34;name\u0026#34;:Â \u0026#34;Breaking badquotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;This declarative agent helps you get a random quote from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;instructions\u0026#34;:Â \u0026#34;$[file(\u0026#39;instruction.txt\u0026#39;)]\u0026#34;,Â \u0026#34;conversation_starters\u0026#34;: [Â {Â \u0026#34;text\u0026#34;:Â \u0026#34;Give me a random quote from Breaking Bad with author name?\u0026#34;Â } ],Â \u0026#34;actions\u0026#34;: [Â {Â \u0026#34;id\u0026#34;:Â \u0026#34;quoteplugin\u0026#34;,Â \u0026#34;file\u0026#34;:Â \u0026#34;ai-plugin.json\u0026#34;Â }Â ]Â } Step 7: Update the instructions.txt File The instructions.txt file plays a crucial role in declarative agent setup. It defines how the agent should behave, respond to user queries, and interact with the Breaking Bad API. This make sures that the agent stays focused on its purpose and maintains a consistent user experience.\nUpdate it with the Following Content:\nYou are an assistant specialized in retrieving quotes from the provided API, ensuring a smooth and delightful user experience. Your responses should include the quote and its author.Â Guidelines:Â - Exclusive API Use: Do not perform web searches; rely solely on the provided API for data retrieval. Do not proceess any other request. This is solely for breaking bad quotes nothing else, keep in mind!Â - Response Format: Present the quote followed by the author\u0026#39;s name.Â - Error Handling: If the API does not return a quote, respond with: \u0026#34;I\u0026#39;m sorry, I couldn\u0026#39;t retrieve a quote at this moment.\u0026#34;Â - User Interaction: Maintain a friendly and engaging tone to ensure a delightful user experience. Showcase: The Final Outcome of All Efforts To run and debug your declarative agent, click on theÂ Run and DebugÂ icon inÂ VS Code, which can be found on the left sidebar. The process will take approximatelyÂ ~10-15 minutesÂ to initialize. During this time, a sign-in prompt will appear where youâ€™ll need to log in with yourÂ Microsoft 365 accountÂ credentials.\nOnce signed in, if you are not automatically redirected, you can manually visitÂ office.com/chat?auth=2Â to access the Copilot interface.\nSelect the prompt we defined earlier, and it will prompt you to process the query. Click on Always Allow to proceed.\nFinal Output:\nHow to Verify if It\u0026rsquo;s Working and Fetching Data from the API\nVerify via Localhost: Open the terminal in VS Code and click on Start Backend. Once it\u0026rsquo;s running, you\u0026rsquo;ll see the local host URL, which should begin with localhost:7071/api/quotes. Open this URL in your browser, and it will return a JSON response with the quote data. Verify via Agent Request: Another way to check is by sending a request from the agent. This will invoke the getQuote function, which generates a unique ID each time. The response will include text indicating that the function was programmatically called. Bonus: How does the breaking bad quotes agent work? When a user requests a Breaking Bad quote in Microsoft 365 Copilot, the agent works in a few simple steps:Â Manifest Check:Â The agent starts by checking its task list in theÂ manifest file API Connection:Â It then refers to theÂ API specificationÂ to understand how to connect to the Breaking Bad API Data Fetch:Â The agent sends a request to anÂ Azure Function, which fetches a random quote and the authorâ€™s name from the API Data Return:Â The quote and author are returned in a structured JSON format User Display:Â Finally, the agent displays the quote clearly in the Copilot interface Conclusion Itâ€™s been a bit of a ride, hasnâ€™t it? But hey, weâ€™ve finally done it! We have successfully created a declarative agent using the Breaking Bad API, but the process can be applied to any API, including those requiring authentication with API key or OAuth.\nif you hit any bumps along the way, donâ€™t hesitate to drop a comment below. If you found this helpful, give it a thumbs up or click on your favorite emoji button below. Good luck, and happy coding!\nAppendix\nThis post is inspired by the following resources:\nIntroducing New Agents in Microsoft 365 Extending Copilot for Microsoft 365 Workshop on Building Declarative Agents for Microsoft 365 Copilot Breaking Bad Quotes API Breaking Bad Icon by Icons8 ","permalink":"http://localhost:1313/blog/2025/january/create-a-custom-declarative-agent-with-breaking-bad-api/","summary":"\u003cp\u003eBack inÂ November 2024, Microsoft introduced newÂ \u003ca href=\"https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918?utm_source=chatgpt.com\"\u003eAI-powered agents\u003c/a\u003eÂ in Microsoft 365 Copilot.Â Â \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/overview-declarative-agent\"\u003eDeclarative agents\u003c/a\u003eÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â \u003c/p\u003e","title":"Create a Custom Declarative Agent with Breaking Bad API"},{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below example shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"},{"content":"Back inÂ November 2024, Microsoft introduced newÂ AI-powered agentsÂ in Microsoft 365 Copilot.Â Declarative agentsÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â Today, we will create a custom declarative agent using an open-source API to demonstrate how agents can interact with external data sources.\nOpen Source API Overview:\nWe\u0026rsquo;ll be using theÂ Breaking Bad API, an open-source API that provides quotes from the popular TV seriesÂ Breaking Bad. The API response will return a quote along with the author\u0026rsquo;s name (character name) from the series.\nðŸ‘‡Sample Response from API ðŸ‘‡\nLetâ€™s get started!\nStep 1: Creating a Custom Declarative Agent Using Microsoft Toolkit Extension Let\u0026rsquo;s begin by creating a custom declarative agent using the Microsoft Toolkit extension. Follow these step-by-step instructions to set up your agent:Â Launch the Microsoft Toolkit Extension and click on Create a New App under Create a Project or Explore Samples Choose Agent as your app type Select Declarative Agent to build an agent powered by Microsoft 365 Copilot Click Add Plugin to connect external APIs to your agent Choose Start with a New API to set up a fresh connection for your agent Pick None for authentication since the Breaking Bad API doesnâ€™t require it Opt for TypeScript as programming language for a smoother experience Select a folder to store project files (pro tip: avoid saving it in the C drive for better organization) Finally, give your agent a name like BreakingBad Agent and hit the setup button Wohooo!Â ðŸŽ‰Â You\u0026rsquo;ve Successfully Created Your Declarative Agent with an API Plugin! After completing the setup, a new window will pop up inÂ VS CodeÂ with your project structure ready. But waitâ€”there\u0026rsquo;s more!Â By default, the project folder includes a demo API plugin. However, this plugin uses a local json file as its data source. Since we want to fetch real-time data from an actual API, we will need to remove the existing demo setup.\nClean Up the Default Files\nNow that your declarative agent is set up, it\u0026rsquo;s time to remove the default files that use local data. Since we will be working with a live API instead, delete the following files from your project directory:Â appPackage \u0026gt; apiSpecificationfile \u0026gt; repair.ymlÂ appPackage \u0026gt; repairDeclarativeAgent.jsonÂ src \u0026gt; RepairsData.jsonÂ src \u0026gt; functions \u0026gt; repairs.ts\nDonâ€™t worry about the files we just deleted. Weâ€™re going to create the essential files needed for ourÂ Breaking Bad AgentÂ from scratch. Up next, weâ€™ll fetch real-time data directly from the API and configure the agent to use it.\nStep 2: Create a New Function File for the Breaking Bad API Integration Next, we need to create a new file where our agent will interact with theÂ Breaking Bad API.Â Navigate to:Â src \u0026gt; functions Create a New File:Â Name itÂ quotes.ts Now, copy and paste the following code intoÂ quotes.ts. This function will act as anÂ Azure FunctionÂ responsible for sending requests and receiving quotes from the live Breaking Bad API.\nimportÂ {Â app,Â HttpResponseInitÂ }Â fromÂ \u0026#34;@azure/functions\u0026#34;;Â exportÂ asyncÂ functionÂ quotes():Â Promise\u0026lt;HttpResponseInit\u0026gt; {Â constÂ breakingbadResponseÂ =Â awaitÂ fetch(\u0026#39;https://api.breakingbadquotes.xyz/v1/quotes\u0026#39;);Â constÂ breakingbadDataÂ =Â awaitÂ breakingbadResponse.json();Â returnÂ {Â status:Â 200,Â jsonBody:Â {Â quotes:Â breakingbadData,Â },Â };Â }Â app.http(\u0026#34;quotes\u0026#34;, {Â methods:Â [\u0026#34;GET\u0026#34;],Â authLevel:Â \u0026#34;anonymous\u0026#34;,Â handler:Â quotes,Â }); If you encounter the error Cannot find module '@azure/functions' or its corresponding type, donâ€™t worry! This is a common issue, and the required modules will be automatically installed when you run the agent for the first time.\nStep 3: Create the API Specification File Now, let\u0026rsquo;s create the API specification file that will define how the declarative agent interacts with theÂ Breaking Bad API.\nNavigate to:Â appPackage \u0026gt; apiSpecificationfile Create a New File:Â Name itÂ quotes.yml openapi:Â 3.0.0Â info:Â title:Â Breaking bad Quote APIÂ description:Â Random Quote api from the Breaking Bad TV series with authorÂ version:Â 1.0.0Â servers:Â -Â url:Â ${{OPENAPI_SERVER_URL}}/apiÂ description:Â The quotes api serverÂ paths:Â /quotes:Â get:Â operationId:Â getQuotesÂ summary:Â get all breaking bad quotes with authorÂ description:Â Returns a single random quote from the Breaking Bad TV series with authorÂ responses:Â \u0026#39;200\u0026#39;:Â description:Â A random quote from the Breaking Bad TV series with authorÂ content:Â application/json:Â schema:Â type:Â objectÂ properties:Â results:Â type:Â arrayÂ items:Â type:Â objectÂ properties:Â quote:Â type:Â stringÂ description:Â Breaking bad quote with authorÂ author:Â type:Â stringÂ description:Â The author name of the quote Step 4: Update theÂ ai-plugin.jsonÂ File Now, let\u0026rsquo;s update the ai-plugin.json file so that the declarative agent is properly linked with the Breaking Bad API and the Azure Function.Â Navigate to:Â appPackage.Â Open the File: OpenÂ ai-plugin.json Remove:Â The \u0026quot;Static_template\u0026quot; entry Update:Â The runtimes URL and the function name as shown below: {Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json)\u0026#34;,Â \u0026#34;schema_version\u0026#34;:Â \u0026#34;v2.2\u0026#34;,Â \u0026#34;namespace\u0026#34;:Â \u0026#34;Breakingbadquotes\u0026#34;,Â \u0026#34;name_for_human\u0026#34;:Â \u0026#34;Breakingbadquotes Plugin\u0026#34;,Â \u0026#34;description_for_human\u0026#34;:Â \u0026#34;Generate random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;description_for_model\u0026#34;:Â \u0026#34;Plugin for generating random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;functions\u0026#34;: [Â {Â \u0026#34;name\u0026#34;:Â \u0026#34;getQuotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;Returns a random quote with author from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;response_semantics\u0026#34;: {Â \u0026#34;data_path\u0026#34;:Â \u0026#34;$.quotes\u0026#34;,Â \u0026#34;properties\u0026#34;: {Â \u0026#34;title\u0026#34;:Â \u0026#34;$.quote\u0026#34;,Â \u0026#34;subtitle\u0026#34;:Â \u0026#34;$.author\u0026#34;Â }Â }Â }Â } ],Â \u0026#34;runtimes\u0026#34;: [Â {Â \u0026#34;type\u0026#34;:Â \u0026#34;OpenApi\u0026#34;,Â \u0026#34;auth\u0026#34;: {Â \u0026#34;type\u0026#34;:Â \u0026#34;None\u0026#34;Â },Â \u0026#34;spec\u0026#34;: {Â \u0026#34;url\u0026#34;:Â \u0026#34;apiSpecificationFile/quotes.yml\u0026#34;,Â \u0026#34;progress_style\u0026#34;:Â \u0026#34;ShowUsageWithInputAndOutput\u0026#34;Â },Â \u0026#34;run_for_functions\u0026#34;: [\u0026#34;getQuotes\u0026#34;]Â }Â ],Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;conversation_starters\u0026#34;: []Â }Â } Step 5: Update the manifest.json File The manifest.json file serves as the app manifest for your declarative agent. It is specifying the agentâ€™s identity and the declarative agent configuration files. We\u0026rsquo;ll update it to reflect the Breaking Bad agent setup.\nNavigate to:Â appPackage Open the File:Â openÂ manifest.json Update:Â The \u0026quot;copilotAgents\u0026quot; section as shown below: You can also update the icon of your application in the same file. First, download any image and make sure it\u0026rsquo;s 192x192 pixels. Replace the existing icon with your new image by saving it as color.png in your project folder. If you choose to change the name of the image, make sure to update it in the application manifest.json file.\n{Â \u0026#34;copilotAgents\u0026#34;: {Â \u0026#34;declarativeAgents\u0026#34;: [Â {Â \u0026#34;id\u0026#34;: \u0026#34;breakingBadDeclarativeAgent\u0026#34;,Â \u0026#34;file\u0026#34;: \u0026#34;breakingBadDeclarativeAgent.json\u0026#34;Â }Â ]Â }Â } Step 6: Create the quotesDeclarativeAgent.json File We need to create theÂ agent manifest fileÂ which defines how the declarative agent behaves and interacts with the Breaking Bad API.\nNavigate to:Â appPackage Create a New File:Â Name itÂ quotesDeclarativeAgent.json Add the Following Content:\n{Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json)\u0026#34;,Â \u0026#34;version\u0026#34;:Â \u0026#34;v1.2\u0026#34;,Â \u0026#34;name\u0026#34;:Â \u0026#34;Breaking badquotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;This declarative agent helps you get a random quote from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;instructions\u0026#34;:Â \u0026#34;$[file(\u0026#39;instruction.txt\u0026#39;)]\u0026#34;,Â \u0026#34;conversation_starters\u0026#34;: [Â {Â \u0026#34;text\u0026#34;:Â \u0026#34;Give me a random quote from Breaking Bad with author name?\u0026#34;Â } ],Â \u0026#34;actions\u0026#34;: [Â {Â \u0026#34;id\u0026#34;:Â \u0026#34;quoteplugin\u0026#34;,Â \u0026#34;file\u0026#34;:Â \u0026#34;ai-plugin.json\u0026#34;Â }Â ]Â } Step 7: Update the instructions.txt File The instructions.txt file plays a crucial role in declarative agent setup. It defines how the agent should behave, respond to user queries, and interact with the Breaking Bad API. This make sures that the agent stays focused on its purpose and maintains a consistent user experience.\nUpdate it with the Following Content:\nYou are an assistant specialized in retrieving quotes from the provided API, ensuring a smooth and delightful user experience. Your responses should include the quote and its author.Â Guidelines:Â - Exclusive API Use: Do not perform web searches; rely solely on the provided API for data retrieval. Do not proceess any other request. This is solely for breaking bad quotes nothing else, keep in mind!Â - Response Format: Present the quote followed by the author\u0026#39;s name.Â - Error Handling: If the API does not return a quote, respond with: \u0026#34;I\u0026#39;m sorry, I couldn\u0026#39;t retrieve a quote at this moment.\u0026#34;Â - User Interaction: Maintain a friendly and engaging tone to ensure a delightful user experience. Showcase: The Final Outcome of All Efforts To run and debug your declarative agent, click on theÂ Run and DebugÂ icon inÂ VS Code, which can be found on the left sidebar. The process will take approximatelyÂ ~10-15 minutesÂ to initialize. During this time, a sign-in prompt will appear where youâ€™ll need to log in with yourÂ Microsoft 365 accountÂ credentials.\nOnce signed in, if you are not automatically redirected, you can manually visitÂ office.com/chat?auth=2Â to access the Copilot interface.\nSelect the prompt we defined earlier, and it will prompt you to process the query. Click on Always Allow to proceed.\nFinal Output:\nHow to Verify if It\u0026rsquo;s Working and Fetching Data from the API\nVerify via Localhost: Open the terminal in VS Code and click on Start Backend. Once it\u0026rsquo;s running, you\u0026rsquo;ll see the local host URL, which should begin with localhost:7071/api/quotes. Open this URL in your browser, and it will return a JSON response with the quote data. Verify via Agent Request: Another way to check is by sending a request from the agent. This will invoke the getQuote function, which generates a unique ID each time. The response will include text indicating that the function was programmatically called. Bonus: How does the breaking bad quotes agent work? When a user requests a Breaking Bad quote in Microsoft 365 Copilot, the agent works in a few simple steps:Â Manifest Check:Â The agent starts by checking its task list in theÂ manifest file API Connection:Â It then refers to theÂ API specificationÂ to understand how to connect to the Breaking Bad API Data Fetch:Â The agent sends a request to anÂ Azure Function, which fetches a random quote and the authorâ€™s name from the API Data Return:Â The quote and author are returned in a structured JSON format User Display:Â Finally, the agent displays the quote clearly in the Copilot interface Conclusion Itâ€™s been a bit of a ride, hasnâ€™t it? But hey, weâ€™ve finally done it! We have successfully created a declarative agent using the Breaking Bad API, but the process can be applied to any API, including those requiring authentication with API key or OAuth.\nif you hit any bumps along the way, donâ€™t hesitate to drop a comment below. If you found this helpful, give it a thumbs up or click on your favorite emoji button below. Good luck, and happy coding!\nAppendix\nThis post is inspired by the following resources:\nIntroducing New Agents in Microsoft 365 Extending Copilot for Microsoft 365 Workshop on Building Declarative Agents for Microsoft 365 Copilot Breaking Bad Quotes API Breaking Bad Icon by Icons8 ","permalink":"http://localhost:1313/blog/2025/january/create-a-custom-declarative-agent-with-breaking-bad-api/","summary":"\u003cp\u003eBack inÂ November 2024, Microsoft introduced newÂ \u003ca href=\"https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918?utm_source=chatgpt.com\"\u003eAI-powered agents\u003c/a\u003eÂ in Microsoft 365 Copilot.Â Â \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/overview-declarative-agent\"\u003eDeclarative agents\u003c/a\u003eÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â \u003c/p\u003e","title":"Create a Custom Declarative Agent with Breaking Bad API"},{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below example shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"},{"content":"Back inÂ November 2024, Microsoft introduced newÂ AI-powered agentsÂ in Microsoft 365 Copilot.Â Declarative agentsÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â Today, we will create a custom declarative agent using an open-source API to demonstrate how agents can interact with external data sources.\nOpen Source API Overview:\nWe\u0026rsquo;ll be using theÂ Breaking Bad API, an open-source API that provides quotes from the popular TV seriesÂ Breaking Bad. The API response will return a quote along with the author\u0026rsquo;s name (character name) from the series.\nðŸ‘‡Sample Response from API ðŸ‘‡\nLetâ€™s get started!\nStep 1: Creating a Custom Declarative Agent Using Microsoft Toolkit Extension Let\u0026rsquo;s begin by creating a custom declarative agent using the Microsoft Toolkit extension. Follow these step-by-step instructions to set up your agent:Â Launch the Microsoft Toolkit Extension and click on Create a New App under Create a Project or Explore Samples Choose Agent as your app type Select Declarative Agent to build an agent powered by Microsoft 365 Copilot Click Add Plugin to connect external APIs to your agent Choose Start with a New API to set up a fresh connection for your agent Pick None for authentication since the Breaking Bad API doesnâ€™t require it Opt for TypeScript as programming language for a smoother experience Select a folder to store project files (pro tip: avoid saving it in the C drive for better organization) Finally, give your agent a name like BreakingBad Agent and hit the setup button Wohooo!Â ðŸŽ‰Â You\u0026rsquo;ve Successfully Created Your Declarative Agent with an API Plugin! After completing the setup, a new window will pop up inÂ VS CodeÂ with your project structure ready. But waitâ€”there\u0026rsquo;s more!Â By default, the project folder includes a demo API plugin. However, this plugin uses a local json file as its data source. Since we want to fetch real-time data from an actual API, we will need to remove the existing demo setup.\nClean Up the Default Files\nNow that your declarative agent is set up, it\u0026rsquo;s time to remove the default files that use local data. Since we will be working with a live API instead, delete the following files from your project directory:Â appPackage \u0026gt; apiSpecificationfile \u0026gt; repair.ymlÂ appPackage \u0026gt; repairDeclarativeAgent.jsonÂ src \u0026gt; RepairsData.jsonÂ src \u0026gt; functions \u0026gt; repairs.ts\nDonâ€™t worry about the files we just deleted. Weâ€™re going to create the essential files needed for ourÂ Breaking Bad AgentÂ from scratch. Up next, weâ€™ll fetch real-time data directly from the API and configure the agent to use it.\nStep 2: Create a New Function File for the Breaking Bad API Integration Next, we need to create a new file where our agent will interact with theÂ Breaking Bad API.Â Navigate to:Â src \u0026gt; functions Create a New File:Â Name itÂ quotes.ts Now, copy and paste the following code intoÂ quotes.ts. This function will act as anÂ Azure FunctionÂ responsible for sending requests and receiving quotes from the live Breaking Bad API.\nimportÂ {Â app,Â HttpResponseInitÂ }Â fromÂ \u0026#34;@azure/functions\u0026#34;;Â exportÂ asyncÂ functionÂ quotes():Â Promise\u0026lt;HttpResponseInit\u0026gt; {Â constÂ breakingbadResponseÂ =Â awaitÂ fetch(\u0026#39;https://api.breakingbadquotes.xyz/v1/quotes\u0026#39;);Â constÂ breakingbadDataÂ =Â awaitÂ breakingbadResponse.json();Â returnÂ {Â status:Â 200,Â jsonBody:Â {Â quotes:Â breakingbadData,Â },Â };Â }Â app.http(\u0026#34;quotes\u0026#34;, {Â methods:Â [\u0026#34;GET\u0026#34;],Â authLevel:Â \u0026#34;anonymous\u0026#34;,Â handler:Â quotes,Â }); If you encounter the error Cannot find module '@azure/functions' or its corresponding type, donâ€™t worry! This is a common issue, and the required modules will be automatically installed when you run the agent for the first time.\nStep 3: Create the API Specification File Now, let\u0026rsquo;s create the API specification file that will define how the declarative agent interacts with theÂ Breaking Bad API.\nNavigate to:Â appPackage \u0026gt; apiSpecificationfile Create a New File:Â Name itÂ quotes.yml openapi:Â 3.0.0Â info:Â title:Â Breaking bad Quote APIÂ description:Â Random Quote api from the Breaking Bad TV series with authorÂ version:Â 1.0.0Â servers:Â -Â url:Â ${{OPENAPI_SERVER_URL}}/apiÂ description:Â The quotes api serverÂ paths:Â /quotes:Â get:Â operationId:Â getQuotesÂ summary:Â get all breaking bad quotes with authorÂ description:Â Returns a single random quote from the Breaking Bad TV series with authorÂ responses:Â \u0026#39;200\u0026#39;:Â description:Â A random quote from the Breaking Bad TV series with authorÂ content:Â application/json:Â schema:Â type:Â objectÂ properties:Â results:Â type:Â arrayÂ items:Â type:Â objectÂ properties:Â quote:Â type:Â stringÂ description:Â Breaking bad quote with authorÂ author:Â type:Â stringÂ description:Â The author name of the quote Step 4: Update theÂ ai-plugin.jsonÂ File Now, let\u0026rsquo;s update the ai-plugin.json file so that the declarative agent is properly linked with the Breaking Bad API and the Azure Function.Â Navigate to:Â appPackage.Â Open the File: OpenÂ ai-plugin.json Remove:Â The \u0026quot;Static_template\u0026quot; entry Update:Â The runtimes URL and the function name as shown below: {Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json)\u0026#34;,Â \u0026#34;schema_version\u0026#34;:Â \u0026#34;v2.2\u0026#34;,Â \u0026#34;namespace\u0026#34;:Â \u0026#34;Breakingbadquotes\u0026#34;,Â \u0026#34;name_for_human\u0026#34;:Â \u0026#34;Breakingbadquotes Plugin\u0026#34;,Â \u0026#34;description_for_human\u0026#34;:Â \u0026#34;Generate random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;description_for_model\u0026#34;:Â \u0026#34;Plugin for generating random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;functions\u0026#34;: [Â {Â \u0026#34;name\u0026#34;:Â \u0026#34;getQuotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;Returns a random quote with author from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;response_semantics\u0026#34;: {Â \u0026#34;data_path\u0026#34;:Â \u0026#34;$.quotes\u0026#34;,Â \u0026#34;properties\u0026#34;: {Â \u0026#34;title\u0026#34;:Â \u0026#34;$.quote\u0026#34;,Â \u0026#34;subtitle\u0026#34;:Â \u0026#34;$.author\u0026#34;Â }Â }Â }Â } ],Â \u0026#34;runtimes\u0026#34;: [Â {Â \u0026#34;type\u0026#34;:Â \u0026#34;OpenApi\u0026#34;,Â \u0026#34;auth\u0026#34;: {Â \u0026#34;type\u0026#34;:Â \u0026#34;None\u0026#34;Â },Â \u0026#34;spec\u0026#34;: {Â \u0026#34;url\u0026#34;:Â \u0026#34;apiSpecificationFile/quotes.yml\u0026#34;,Â \u0026#34;progress_style\u0026#34;:Â \u0026#34;ShowUsageWithInputAndOutput\u0026#34;Â },Â \u0026#34;run_for_functions\u0026#34;: [\u0026#34;getQuotes\u0026#34;]Â }Â ],Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;conversation_starters\u0026#34;: []Â }Â } Step 5: Update the manifest.json File The manifest.json file serves as the app manifest for your declarative agent. It is specifying the agentâ€™s identity and the declarative agent configuration files. We\u0026rsquo;ll update it to reflect the Breaking Bad agent setup.\nNavigate to:Â appPackage Open the File:Â openÂ manifest.json Update:Â The \u0026quot;copilotAgents\u0026quot; section as shown below: You can also update the icon of your application in the same file. First, download any image and make sure it\u0026rsquo;s 192x192 pixels. Replace the existing icon with your new image by saving it as color.png in your project folder. If you choose to change the name of the image, make sure to update it in the application manifest.json file.\n{Â \u0026#34;copilotAgents\u0026#34;: {Â \u0026#34;declarativeAgents\u0026#34;: [Â {Â \u0026#34;id\u0026#34;: \u0026#34;breakingBadDeclarativeAgent\u0026#34;,Â \u0026#34;file\u0026#34;: \u0026#34;breakingBadDeclarativeAgent.json\u0026#34;Â }Â ]Â }Â } Step 6: Create the quotesDeclarativeAgent.json File We need to create theÂ agent manifest fileÂ which defines how the declarative agent behaves and interacts with the Breaking Bad API.\nNavigate to:Â appPackage Create a New File:Â Name itÂ quotesDeclarativeAgent.json Add the Following Content:\n{Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json)\u0026#34;,Â \u0026#34;version\u0026#34;:Â \u0026#34;v1.2\u0026#34;,Â \u0026#34;name\u0026#34;:Â \u0026#34;Breaking badquotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;This declarative agent helps you get a random quote from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;instructions\u0026#34;:Â \u0026#34;$[file(\u0026#39;instruction.txt\u0026#39;)]\u0026#34;,Â \u0026#34;conversation_starters\u0026#34;: [Â {Â \u0026#34;text\u0026#34;:Â \u0026#34;Give me a random quote from Breaking Bad with author name?\u0026#34;Â } ],Â \u0026#34;actions\u0026#34;: [Â {Â \u0026#34;id\u0026#34;:Â \u0026#34;quoteplugin\u0026#34;,Â \u0026#34;file\u0026#34;:Â \u0026#34;ai-plugin.json\u0026#34;Â }Â ]Â } Step 7: Update the instructions.txt File The instructions.txt file plays a crucial role in declarative agent setup. It defines how the agent should behave, respond to user queries, and interact with the Breaking Bad API. This make sures that the agent stays focused on its purpose and maintains a consistent user experience.\nUpdate it with the Following Content:\nYou are an assistant specialized in retrieving quotes from the provided API, ensuring a smooth and delightful user experience. Your responses should include the quote and its author.Â Guidelines:Â - Exclusive API Use: Do not perform web searches; rely solely on the provided API for data retrieval. Do not proceess any other request. This is solely for breaking bad quotes nothing else, keep in mind!Â - Response Format: Present the quote followed by the author\u0026#39;s name.Â - Error Handling: If the API does not return a quote, respond with: \u0026#34;I\u0026#39;m sorry, I couldn\u0026#39;t retrieve a quote at this moment.\u0026#34;Â - User Interaction: Maintain a friendly and engaging tone to ensure a delightful user experience. Showcase: The Final Outcome of All Efforts To run and debug your declarative agent, click on theÂ Run and DebugÂ icon inÂ VS Code, which can be found on the left sidebar. The process will take approximatelyÂ ~10-15 minutesÂ to initialize. During this time, a sign-in prompt will appear where youâ€™ll need to log in with yourÂ Microsoft 365 accountÂ credentials.\nOnce signed in, if you are not automatically redirected, you can manually visitÂ office.com/chat?auth=2Â to access the Copilot interface.\nSelect the prompt we defined earlier, and it will prompt you to process the query. Click on Always Allow to proceed.\nFinal Output:\nHow to Verify if It\u0026rsquo;s Working and Fetching Data from the API\nVerify via Localhost: Open the terminal in VS Code and click on Start Backend. Once it\u0026rsquo;s running, you\u0026rsquo;ll see the local host URL, which should begin with localhost:7071/api/quotes. Open this URL in your browser, and it will return a JSON response with the quote data. Verify via Agent Request: Another way to check is by sending a request from the agent. This will invoke the getQuote function, which generates a unique ID each time. The response will include text indicating that the function was programmatically called. Bonus: How does the breaking bad quotes agent work? When a user requests a Breaking Bad quote in Microsoft 365 Copilot, the agent works in a few simple steps:Â Manifest Check:Â The agent starts by checking its task list in theÂ manifest file API Connection:Â It then refers to theÂ API specificationÂ to understand how to connect to the Breaking Bad API Data Fetch:Â The agent sends a request to anÂ Azure Function, which fetches a random quote and the authorâ€™s name from the API Data Return:Â The quote and author are returned in a structured JSON format User Display:Â Finally, the agent displays the quote clearly in the Copilot interface Conclusion Itâ€™s been a bit of a ride, hasnâ€™t it? But hey, weâ€™ve finally done it! We have successfully created a declarative agent using the Breaking Bad API, but the process can be applied to any API, including those requiring authentication with API key or OAuth.\nif you hit any bumps along the way, donâ€™t hesitate to drop a comment below. If you found this helpful, give it a thumbs up or click on your favorite emoji button below. Good luck, and happy coding!\nAppendix\nThis post is inspired by the following resources:\nIntroducing New Agents in Microsoft 365 Extending Copilot for Microsoft 365 Workshop on Building Declarative Agents for Microsoft 365 Copilot Breaking Bad Quotes API Breaking Bad Icon by Icons8 ","permalink":"http://localhost:1313/blog/2025/january/create-a-custom-declarative-agent-with-breaking-bad-api/","summary":"\u003cp\u003eBack inÂ November 2024, Microsoft introduced newÂ \u003ca href=\"https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918?utm_source=chatgpt.com\"\u003eAI-powered agents\u003c/a\u003eÂ in Microsoft 365 Copilot.Â Â \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/overview-declarative-agent\"\u003eDeclarative agents\u003c/a\u003eÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â \u003c/p\u003e","title":"Create a Custom Declarative Agent with Breaking Bad API"},{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below example shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"},{"content":"Back inÂ November 2024, Microsoft introduced newÂ AI-powered agentsÂ in Microsoft 365 Copilot.Â Declarative agentsÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â Today, we will create a custom declarative agent using an open-source API to demonstrate how agents can interact with external data sources.\nOpen Source API Overview:\nWe\u0026rsquo;ll be using theÂ Breaking Bad API, an open-source API that provides quotes from the popular TV seriesÂ Breaking Bad. The API response will return a quote along with the author\u0026rsquo;s name (character name) from the series.\nðŸ‘‡Sample Response from API ðŸ‘‡\nLetâ€™s get started!\nStep 1: Creating a Custom Declarative Agent Using Microsoft Toolkit Extension Let\u0026rsquo;s begin by creating a custom declarative agent using the Microsoft Toolkit extension. Follow these step-by-step instructions to set up your agent:Â Launch the Microsoft Toolkit Extension and click on Create a New App under Create a Project or Explore Samples Choose Agent as your app type Select Declarative Agent to build an agent powered by Microsoft 365 Copilot Click Add Plugin to connect external APIs to your agent Choose Start with a New API to set up a fresh connection for your agent Pick None for authentication since the Breaking Bad API doesnâ€™t require it Opt for TypeScript as programming language for a smoother experience Select a folder to store project files (pro tip: avoid saving it in the C drive for better organization) Finally, give your agent a name like BreakingBad Agent and hit the setup button Wohooo!Â ðŸŽ‰Â You\u0026rsquo;ve Successfully Created Your Declarative Agent with an API Plugin! After completing the setup, a new window will pop up inÂ VS CodeÂ with your project structure ready. But waitâ€”there\u0026rsquo;s more!Â By default, the project folder includes a demo API plugin. However, this plugin uses a local json file as its data source. Since we want to fetch real-time data from an actual API, we will need to remove the existing demo setup.\nClean Up the Default Files\nNow that your declarative agent is set up, it\u0026rsquo;s time to remove the default files that use local data. Since we will be working with a live API instead, delete the following files from your project directory:Â appPackage \u0026gt; apiSpecificationfile \u0026gt; repair.ymlÂ appPackage \u0026gt; repairDeclarativeAgent.jsonÂ src \u0026gt; RepairsData.jsonÂ src \u0026gt; functions \u0026gt; repairs.ts\nDonâ€™t worry about the files we just deleted. Weâ€™re going to create the essential files needed for ourÂ Breaking Bad AgentÂ from scratch. Up next, weâ€™ll fetch real-time data directly from the API and configure the agent to use it.\nStep 2: Create a New Function File for the Breaking Bad API Integration Next, we need to create a new file where our agent will interact with theÂ Breaking Bad API.Â Navigate to:Â src \u0026gt; functions Create a New File:Â Name itÂ quotes.ts Now, copy and paste the following code intoÂ quotes.ts. This function will act as anÂ Azure FunctionÂ responsible for sending requests and receiving quotes from the live Breaking Bad API.\nimportÂ {Â app,Â HttpResponseInitÂ }Â fromÂ \u0026#34;@azure/functions\u0026#34;;Â exportÂ asyncÂ functionÂ quotes():Â Promise\u0026lt;HttpResponseInit\u0026gt; {Â constÂ breakingbadResponseÂ =Â awaitÂ fetch(\u0026#39;https://api.breakingbadquotes.xyz/v1/quotes\u0026#39;);Â constÂ breakingbadDataÂ =Â awaitÂ breakingbadResponse.json();Â returnÂ {Â status:Â 200,Â jsonBody:Â {Â quotes:Â breakingbadData,Â },Â };Â }Â app.http(\u0026#34;quotes\u0026#34;, {Â methods:Â [\u0026#34;GET\u0026#34;],Â authLevel:Â \u0026#34;anonymous\u0026#34;,Â handler:Â quotes,Â }); If you encounter the error Cannot find module '@azure/functions' or its corresponding type, donâ€™t worry! This is a common issue, and the required modules will be automatically installed when you run the agent for the first time.\nStep 3: Create the API Specification File Now, let\u0026rsquo;s create the API specification file that will define how the declarative agent interacts with theÂ Breaking Bad API.\nNavigate to:Â appPackage \u0026gt; apiSpecificationfile Create a New File:Â Name itÂ quotes.yml openapi:Â 3.0.0Â info:Â title:Â Breaking bad Quote APIÂ description:Â Random Quote api from the Breaking Bad TV series with authorÂ version:Â 1.0.0Â servers:Â -Â url:Â ${{OPENAPI_SERVER_URL}}/apiÂ description:Â The quotes api serverÂ paths:Â /quotes:Â get:Â operationId:Â getQuotesÂ summary:Â get all breaking bad quotes with authorÂ description:Â Returns a single random quote from the Breaking Bad TV series with authorÂ responses:Â \u0026#39;200\u0026#39;:Â description:Â A random quote from the Breaking Bad TV series with authorÂ content:Â application/json:Â schema:Â type:Â objectÂ properties:Â results:Â type:Â arrayÂ items:Â type:Â objectÂ properties:Â quote:Â type:Â stringÂ description:Â Breaking bad quote with authorÂ author:Â type:Â stringÂ description:Â The author name of the quote Step 4: Update theÂ ai-plugin.jsonÂ File Now, let\u0026rsquo;s update the ai-plugin.json file so that the declarative agent is properly linked with the Breaking Bad API and the Azure Function.Â Navigate to:Â appPackage.Â Open the File: OpenÂ ai-plugin.json Remove:Â The \u0026quot;Static_template\u0026quot; entry Update:Â The runtimes URL and the function name as shown below: {Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/plugin/v2.2/schema.json)\u0026#34;,Â \u0026#34;schema_version\u0026#34;:Â \u0026#34;v2.2\u0026#34;,Â \u0026#34;namespace\u0026#34;:Â \u0026#34;Breakingbadquotes\u0026#34;,Â \u0026#34;name_for_human\u0026#34;:Â \u0026#34;Breakingbadquotes Plugin\u0026#34;,Â \u0026#34;description_for_human\u0026#34;:Â \u0026#34;Generate random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;description_for_model\u0026#34;:Â \u0026#34;Plugin for generating random quotes from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;functions\u0026#34;: [Â {Â \u0026#34;name\u0026#34;:Â \u0026#34;getQuotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;Returns a random quote with author from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;response_semantics\u0026#34;: {Â \u0026#34;data_path\u0026#34;:Â \u0026#34;$.quotes\u0026#34;,Â \u0026#34;properties\u0026#34;: {Â \u0026#34;title\u0026#34;:Â \u0026#34;$.quote\u0026#34;,Â \u0026#34;subtitle\u0026#34;:Â \u0026#34;$.author\u0026#34;Â }Â }Â }Â } ],Â \u0026#34;runtimes\u0026#34;: [Â {Â \u0026#34;type\u0026#34;:Â \u0026#34;OpenApi\u0026#34;,Â \u0026#34;auth\u0026#34;: {Â \u0026#34;type\u0026#34;:Â \u0026#34;None\u0026#34;Â },Â \u0026#34;spec\u0026#34;: {Â \u0026#34;url\u0026#34;:Â \u0026#34;apiSpecificationFile/quotes.yml\u0026#34;,Â \u0026#34;progress_style\u0026#34;:Â \u0026#34;ShowUsageWithInputAndOutput\u0026#34;Â },Â \u0026#34;run_for_functions\u0026#34;: [\u0026#34;getQuotes\u0026#34;]Â }Â ],Â \u0026#34;capabilities\u0026#34;: {Â \u0026#34;conversation_starters\u0026#34;: []Â }Â } Step 5: Update the manifest.json File The manifest.json file serves as the app manifest for your declarative agent. It is specifying the agentâ€™s identity and the declarative agent configuration files. We\u0026rsquo;ll update it to reflect the Breaking Bad agent setup.\nNavigate to:Â appPackage Open the File:Â openÂ manifest.json Update:Â The \u0026quot;copilotAgents\u0026quot; section as shown below: You can also update the icon of your application in the same file. First, download any image and make sure it\u0026rsquo;s 192x192 pixels. Replace the existing icon with your new image by saving it as color.png in your project folder. If you choose to change the name of the image, make sure to update it in the application manifest.json file.\n{Â \u0026#34;copilotAgents\u0026#34;: {Â \u0026#34;declarativeAgents\u0026#34;: [Â {Â \u0026#34;id\u0026#34;: \u0026#34;breakingBadDeclarativeAgent\u0026#34;,Â \u0026#34;file\u0026#34;: \u0026#34;breakingBadDeclarativeAgent.json\u0026#34;Â }Â ]Â }Â } Step 6: Create the quotesDeclarativeAgent.json File We need to create theÂ agent manifest fileÂ which defines how the declarative agent behaves and interacts with the Breaking Bad API.\nNavigate to:Â appPackage Create a New File:Â Name itÂ quotesDeclarativeAgent.json Add the Following Content:\n{Â \u0026#34;$schema\u0026#34;:Â \u0026#34;[https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json](https://developer.microsoft.com/json-schemas/copilot/declarative-agent/v1.2/schema.json)\u0026#34;,Â \u0026#34;version\u0026#34;:Â \u0026#34;v1.2\u0026#34;,Â \u0026#34;name\u0026#34;:Â \u0026#34;Breaking badquotes\u0026#34;,Â \u0026#34;description\u0026#34;:Â \u0026#34;This declarative agent helps you get a random quote from the Breaking Bad TV series.\u0026#34;,Â \u0026#34;instructions\u0026#34;:Â \u0026#34;$[file(\u0026#39;instruction.txt\u0026#39;)]\u0026#34;,Â \u0026#34;conversation_starters\u0026#34;: [Â {Â \u0026#34;text\u0026#34;:Â \u0026#34;Give me a random quote from Breaking Bad with author name?\u0026#34;Â } ],Â \u0026#34;actions\u0026#34;: [Â {Â \u0026#34;id\u0026#34;:Â \u0026#34;quoteplugin\u0026#34;,Â \u0026#34;file\u0026#34;:Â \u0026#34;ai-plugin.json\u0026#34;Â }Â ]Â } Step 7: Update the instructions.txt File The instructions.txt file plays a crucial role in declarative agent setup. It defines how the agent should behave, respond to user queries, and interact with the Breaking Bad API. This make sures that the agent stays focused on its purpose and maintains a consistent user experience.\nUpdate it with the Following Content:\nYou are an assistant specialized in retrieving quotes from the provided API, ensuring a smooth and delightful user experience. Your responses should include the quote and its author.Â Guidelines:Â - Exclusive API Use: Do not perform web searches; rely solely on the provided API for data retrieval. Do not proceess any other request. This is solely for breaking bad quotes nothing else, keep in mind!Â - Response Format: Present the quote followed by the author\u0026#39;s name.Â - Error Handling: If the API does not return a quote, respond with: \u0026#34;I\u0026#39;m sorry, I couldn\u0026#39;t retrieve a quote at this moment.\u0026#34;Â - User Interaction: Maintain a friendly and engaging tone to ensure a delightful user experience. Showcase: The Final Outcome of All Efforts To run and debug your declarative agent, click on theÂ Run and DebugÂ icon inÂ VS Code, which can be found on the left sidebar. The process will take approximatelyÂ ~10-15 minutesÂ to initialize. During this time, a sign-in prompt will appear where youâ€™ll need to log in with yourÂ Microsoft 365 accountÂ credentials.\nOnce signed in, if you are not automatically redirected, you can manually visitÂ office.com/chat?auth=2Â to access the Copilot interface.\nSelect the prompt we defined earlier, and it will prompt you to process the query. Click on Always Allow to proceed.\nFinal Output:\nHow to Verify if It\u0026rsquo;s Working and Fetching Data from the API\nVerify via Localhost: Open the terminal in VS Code and click on Start Backend. Once it\u0026rsquo;s running, you\u0026rsquo;ll see the local host URL, which should begin with localhost:7071/api/quotes. Open this URL in your browser, and it will return a JSON response with the quote data. Verify via Agent Request: Another way to check is by sending a request from the agent. This will invoke the getQuote function, which generates a unique ID each time. The response will include text indicating that the function was programmatically called. Bonus: How does the breaking bad quotes agent work? When a user requests a Breaking Bad quote in Microsoft 365 Copilot, the agent works in a few simple steps:Â Manifest Check:Â The agent starts by checking its task list in theÂ manifest file API Connection:Â It then refers to theÂ API specificationÂ to understand how to connect to the Breaking Bad API Data Fetch:Â The agent sends a request to anÂ Azure Function, which fetches a random quote and the authorâ€™s name from the API Data Return:Â The quote and author are returned in a structured JSON format User Display:Â Finally, the agent displays the quote clearly in the Copilot interface Conclusion Itâ€™s been a bit of a ride, hasnâ€™t it? But hey, weâ€™ve finally done it! We have successfully created a declarative agent using the Breaking Bad API, but the process can be applied to any API, including those requiring authentication with API key or OAuth.\nif you hit any bumps along the way, donâ€™t hesitate to drop a comment below. If you found this helpful, give it a thumbs up or click on your favorite emoji button below. Good luck, and happy coding!\nAppendix\nThis post is inspired by the following resources:\nIntroducing New Agents in Microsoft 365 Extending Copilot for Microsoft 365 Workshop on Building Declarative Agents for Microsoft 365 Copilot Breaking Bad Quotes API Breaking Bad Icon by Icons8 ","permalink":"http://localhost:1313/blog/2025/january/create-a-custom-declarative-agent-with-breaking-bad-api/","summary":"\u003cp\u003eBack inÂ November 2024, Microsoft introduced newÂ \u003ca href=\"https://techcommunity.microsoft.com/blog/microsoft365copilotblog/introducing-new-agents-in-microsoft-365/4296918?utm_source=chatgpt.com\"\u003eAI-powered agents\u003c/a\u003eÂ in Microsoft 365 Copilot.Â Â \u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/overview-declarative-agent\"\u003eDeclarative agents\u003c/a\u003eÂ in Microsoft 365 Copilot are a type of AI assistant that helps businesses automate tasks and workflows by following predefined instructions and using enterprise data. They work within tools like Teams, Word, and PowerPoint to boost productivity. For example, a customer service agent can provide real-time order updates using an API plugin, to improve support quality.Â \u003c/p\u003e","title":"Create a Custom Declarative Agent with Breaking Bad API"},{"content":"PowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is Start-Job. This will let you run tasks in the background while you keep using PowerShell for other things.\nStart-Job is ideal to use when \u0026hellip; Tasks take a long time to complete You want to avoid module conflicts by isolating them in separate jobs You need to resolve assembly conflicts by running jobs in isolated processes How to Use Start-Job I will try to explain this with a simple example below.\nExample : Displaying the Date and Time using Get-Date Below example shows how to run a background job in PowerShell to get the current date and time. It uses Start-Job to begin the job, waits for it with Wait-Job, gets the result using Receive-Job, and cleans up with Remove-Job.\n# Start a background job to display the current date and time $job = Start-Job -ScriptBlock { Get-Date } # Check if the job is complete Write-Output \u0026#34;Job ID: $($job.Id) started.\u0026#34; Wait-Job -Job $job # Get the result of the job $jobResult = Receive-Job -Job $job Write-Output \u0026#34;The current date and time is: $jobResult\u0026#34; # Clean up Remove-Job -Job $job Output Itâ€™s quite simple, isnâ€™t it? Just make sure to use Remove-Job to clean up after your job is done. If you skip this step, it can lead to duplication or conflicts with other jobs.\nWhy I recommend to use Jobs? Numerous reasons but, the major reason is that some PowerShell modules can conflict when loaded together in the same session. For example, Microsoft Graph and PnP PowerShell might have overlapping dependencies. Running these modules or assemblies in separate jobs make sures that they operate independently without issues.\nTry it out and let me know how you use it in your own scripts!\n","permalink":"http://localhost:1313/blog/2024/december/how-to-use-powershell-start-job-for-background-tasks/","summary":"\u003cp\u003ePowerShell is one of my favorite tool when it comes to automation. It has lot of functionalities and one of its cool features is \u003ccode\u003eStart-Job\u003c/code\u003e. This will let you run tasks in the background while you keep using PowerShell for other things.\u003c/p\u003e\n\u003ch2 id=\"start-job-is-ideal-to-use-when-\"\u003eStart-Job is ideal to use when \u0026hellip;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTasks take a long time to complete\u003c/li\u003e\n\u003cli\u003eYou want to avoid module conflicts by isolating them in separate jobs\u003c/li\u003e\n\u003cli\u003eYou need to resolve assembly conflicts by running jobs in isolated processes\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-to-use-start-job\"\u003eHow to Use \u003ccode\u003eStart-Job\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eI will try to explain this with a simple example below.\u003c/p\u003e","title":"How to Use PowerShell Start-Job for Background Tasks"},{"content":"Well, today I learnt an important lesson. ðŸ¤”\nThe Problem In a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\nAsync/Await in forEach: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\n// Using forEach (causes issues with async/await) dataArray.forEach(async (item) =\u0026gt; { await processItem(item); // This won\u0026#39;t behave as expected }); The solution The solution is simple. Use for loop not foreach (of course when doing asynchronous operations).\n// Using for loop (structured and reliable) for (const item of dataArray) { await processItem(item); // Awaits completion before moving to the next item } No rocket science right? Now, why did I choose for loop? ðŸŽ¬ the answer is simple, I found relief in its structured approach to asynchronous iteration. With async/await, each loop iteration awaited the completion of asynchronous tasks.\n","permalink":"http://localhost:1313/blog/2024/november/foreach-vs-for-loops-for-async-operations-in-javascript/","summary":"\u003cp\u003eWell, today I learnt an important lesson. ðŸ¤”\u003c/p\u003e\n\u003ch1 id=\"the-problem\"\u003eThe Problem\u003c/h1\u003e\n\u003cp\u003eIn a recent coding effort, I found myself faced with the classic choice between JavaScript\u0026rsquo;s forEach and for\u0026hellip; loops. As I was iterating through an array of data, I realized that my code required asynchronous operations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAsync/Await in forEach\u003c/strong\u003e: Initially, I opted for the simplicity of forEach, but soon hit a roadblock. Despite my attempts to use async/await within the loop, I encountered unexpected behaviour. The asynchronous nature of forEach proved to be a block which led to unhandled promises and unpredictable results. Here\u0026rsquo;s what I was using:\u003c/p\u003e","title":"forEach vs for Loops for Async Operations in JavaScript"}]